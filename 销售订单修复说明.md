# 销售订单功能修复说明

## 修复时间
2025年12月5日

## 问题描述

用户打开销售订单页面时,提示"加载数据失败",后端返回500错误。

### 错误信息
```
❌ 加载订单失败: 
Object { message: "Request failed with status code 500", name: "AxiosError", code: "ERR_BAD_RESPONSE", status: 500 }
```

## 根本原因

销售订单功能还在使用**SQLite数据库API**,而项目已经迁移到**MySQL**,导致数据库操作失败。

### 具体问题

1. **后端路由使用SQLite API**
   - 文件: `backend/routes/salesOrders.js`  
   - 使用了 `db.prepare().get()` 和 `db.prepare().all()` 等SQLite专用方法
   - MySQL需要使用异步的 `connection.execute()` 方法

2. **MySQL数据库缺少销售订单表**
   - `sales_orders` (销售订单主表)
   - `sales_order_products` (订单产品明细表)
   - `sales_order_payment_schedule` (回款计划表)

## 修复方案

###  1. 在MySQL中创建销售订单表

**修改文件**: `/backend/config/database.js`

在 `initializeDatabase()` 函数中添加了3个销售订单相关表:

#### sales_orders (销售订单表)
```sql
CREATE TABLE IF NOT EXISTS sales_orders (
  id VARCHAR(100) PRIMARY KEY,
  internal_order_no VARCHAR(100) UNIQUE NOT NULL,
  customer_order_no VARCHAR(100),
  customer_name VARCHAR(200) NOT NULL,
  customer_id VARCHAR(100),
  salesperson VARCHAR(100),
  quotation_no VARCHAR(100),
  order_type VARCHAR(50),
  order_time DATETIME,
  promised_delivery DATETIME,
  customer_delivery DATETIME,
  estimated_completion_date DATETIME,
  sales_department VARCHAR(100),
  delivery_method VARCHAR(50),
  return_order_no VARCHAR(100),
  order_currency VARCHAR(20) DEFAULT 'CNY',
  current_exchange_rate DECIMAL(10,4) DEFAULT 1.0000,
  tax_rate DECIMAL(5,2) DEFAULT 13.00,
  fees DECIMAL(10,2) DEFAULT 0.00,
  total_amount DECIMAL(10,2) DEFAULT 0.00,
  total_amount_excluding_tax DECIMAL(10,2) DEFAULT 0.00,
  total_tax DECIMAL(10,2) DEFAULT 0.00,
  order_attachment VARCHAR(500),
  packaging_attachment VARCHAR(500),
  order_notes TEXT,
  packaging_method VARCHAR(100),
  packaging_requirements TEXT,
  consignee VARCHAR(100),
  delivery_address VARCHAR(500),
  bill_recipient VARCHAR(100),
  bill_address VARCHAR(500),
  payment_method VARCHAR(50),
  advance_payment_ratio DECIMAL(5,2) DEFAULT 0.00,
  advance_payment_amount DECIMAL(10,2) DEFAULT 0.00,
  planned_payment_account VARCHAR(100),
  total_receivable DECIMAL(10,2) DEFAULT 0.00,
  has_after_sales TINYINT DEFAULT 0,
  after_sales_order_no VARCHAR(100),
  after_sales_details TEXT,
  status VARCHAR(50) DEFAULT 'draft',
  created_by VARCHAR(100) DEFAULT 'admin',
  updated_by VARCHAR(100),
  created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
  updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
  INDEX idx_internal_order_no (internal_order_no),
  INDEX idx_customer_order_no (customer_order_no),
  INDEX idx_customer_name (customer_name),
  INDEX idx_status (status),
  INDEX idx_created_at (created_at)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci;
```

#### sales_order_products (订单产品明细表)
```sql
CREATE TABLE IF NOT EXISTS sales_order_products (
  id INT AUTO_INCREMENT PRIMARY KEY,
  order_id VARCHAR(100) NOT NULL,
  product_code VARCHAR(100) NOT NULL,
  product_name VARCHAR(200) NOT NULL,
  product_spec VARCHAR(200),
  product_color VARCHAR(100),
  product_unit VARCHAR(20),
  order_quantity DECIMAL(10,2) NOT NULL,
  unit_price_excluding_tax DECIMAL(10,2) DEFAULT 0.00,
  tax_rate DECIMAL(5,2) DEFAULT 13.00,
  total_price_excluding_tax DECIMAL(10,2) DEFAULT 0.00,
  total_tax DECIMAL(10,2) DEFAULT 0.00,
  total_price DECIMAL(10,2) DEFAULT 0.00,
  accessories TEXT,
  created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
  updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
  INDEX idx_order_id (order_id),
  INDEX idx_product_code (product_code),
  FOREIGN KEY (order_id) REFERENCES sales_orders(id) ON DELETE CASCADE
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci;
```

#### sales_order_payment_schedule (回款计划表)
```sql
CREATE TABLE IF NOT EXISTS sales_order_payment_schedule (
  id INT AUTO_INCREMENT PRIMARY KEY,
  order_id VARCHAR(100) NOT NULL,
  payment_ratio DECIMAL(5,2) NOT NULL,
  payment_amount DECIMAL(10,2) NOT NULL,
  payment_date DATE NOT NULL,
  payment_account VARCHAR(100),
  created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
  updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
  INDEX idx_order_id (order_id),
  INDEX idx_payment_date (payment_date),
  FOREIGN KEY (order_id) REFERENCES sales_orders(id) ON DELETE CASCADE
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci;
```

### 2. 重写销售订单路由(SQLite → MySQL)

**修改文件**: `/backend/routes/salesOrders.js`

#### 主要改动

1. **引入MySQL连接池**
```javascript
// ❌ 旧代码 (SQLite)
const db = require('../config/database')

// ✅ 新代码 (MySQL)
const pool = require('../config/database')
const { v4: uuidv4 } = require('uuid')
```

2. **获取订单列表 (GET /api/sales-orders)**
```javascript
// ❌ SQLite 同步API
const total = db.prepare(countSQL).get(...params).total
const orders = db.prepare(dataSQL).all(...params, parseInt(pageSize), offset)

// ✅ MySQL 异步API
connection = await pool.getConnection()
const [countResult] = await connection.execute(countSQL, params)
const total = countResult[0].total

const [orders] = await connection.execute(dataSQL, params)
connection.release()
```

3. **获取订单详情 (GET /api/sales-orders/:id)**
```javascript
// ❌ SQLite
const order = db.prepare('SELECT * FROM sales_orders WHERE id = ?').get(id)
const products = db.prepare('SELECT * FROM sales_order_products WHERE order_id = ?').all(id)

// ✅ MySQL
const [orders] = await connection.execute('SELECT * FROM sales_orders WHERE id = ?', [id])
const order = orders[0]
const [products] = await connection.execute('SELECT * FROM sales_order_products WHERE order_id = ?', [id])
```

4. **创建订单 (POST /api/sales-orders)** - 使用事务
```javascript
// ✅ MySQL 事务处理
await connection.beginTransaction()

try {
  // 插入主订单
  await connection.execute(`INSERT INTO sales_orders (...) VALUES (...)`, [...])
  
  // 插入产品明细
  for (const product of products) {
    await connection.execute(`INSERT INTO sales_order_products (...) VALUES (...)`, [...])
  }
  
  // 插入回款计划
  for (const payment of paymentSchedule) {
    await connection.execute(`INSERT INTO sales_order_payment_schedule (...) VALUES (...)`, [...])
  }
  
  await connection.commit()
} catch (error) {
  await connection.rollback()
  throw error
}
```

5. **更新订单 (PUT /api/sales-orders/:id)** - 使用事务
6. **删除订单 (DELETE /api/sales-orders/:id)**  
7. **批量删除 (POST /api/sales-orders/batch-delete)**

#### 重要修复: LIMIT/OFFSET参数问题

**问题**: MySQL2的execute方法在处理LIMIT/OFFSET占位符时存在兼容性问题

**解决方案**: 将LIMIT/OFFSET直接拼接到SQL中,而不使用占位符

```javascript
// ❌ 使用占位符 (会报错: Incorrect arguments to mysqld_stmt_execute)
const dataSQL = `
  SELECT * FROM sales_orders 
  ${whereSQL}
  ORDER BY created_at DESC 
  LIMIT ? OFFSET ?
`
const [orders] = await connection.execute(dataSQL, [...params, limitPageSize, offset])

// ✅ 直接拼接 (正确)
const offset = (parseInt(page) - 1) * parseInt(pageSize)
const limitPageSize = parseInt(pageSize)
const dataSQL = `
  SELECT * FROM sales_orders 
  ${whereSQL}
  ORDER BY created_at DESC 
  LIMIT ${limitPageSize} OFFSET ${offset}
`
const [orders] = await connection.execute(dataSQL, params)
```

## 验证结果

### 数据库表创建成功
```bash
mysql> SHOW TABLES LIKE 'sales%';
+-------------------------------------+
| Tables_in_enterprise_brain (sales%) |
+-------------------------------------+
| sales_boms                          |
| sales_order_payment_schedule        |
| sales_order_products                |
| sales_orders                        |
+-------------------------------------+
```

### API测试成功
```bash
$ curl 'http://localhost:3005/api/sales-orders?page=1&pageSize=10'
{
    "success": true,
    "data": {
        "list": [],
        "total": 0,
        "page": 1,
        "pageSize": 10
    }
}
```

✅ 返回空列表是正常的,因为数据库是全新的,还没有订单数据。

## 影响范围

### 修改的文件
1. `/backend/config/database.js` - 添加销售订单表结构  
2. `/backend/routes/salesOrders.js` - 完全重写为MySQL版本

### 涉及的API
- `GET /api/sales-orders` - 获取订单列表
- `GET /api/sales-orders/:id` - 获取订单详情  
- `POST /api/sales-orders` - 创建订单
- `PUT /api/sales-orders/:id` - 更新订单
- `DELETE /api/sales-orders/:id` - 删除订单
- `POST /api/sales-orders/batch-delete` - 批量删除

## 注意事项

1. **数据迁移**: 如果SQLite中有旧的销售订单数据,需要手动迁移到MySQL
2. **UUID主键**: 新订单使用UUID作为主键,而不是自增ID
3. **事务支持**: 创建和更新订单使用MySQL事务,保证数据一致性
4. **级联删除**: 删除订单时,会自动删除关联的产品明细和回款计划
5. **连接池管理**: 每个请求都要正确获取和释放数据库连接

## 测试建议

1. **基本功能测试**
   - ✅ 查询订单列表(空列表)
   - ⚠️ 创建新订单
   - ⚠️ 查询订单详情
   - ⚠️ 更新订单
   - ⚠️ 删除订单
   - ⚠️ 批量删除

2. **前端集成测试**
   - 打开销售订单页面,确认不再提示"加载失败"
   - 测试订单的增删改查功能
   - 测试产品明细和回款计划的录入

3. **性能测试**
   - 测试大数据量分页查询
   - 测试并发创建订单

## 总结

销售订单功能已从SQLite成功迁移到MySQL,解决了500错误问题。所有API都已重写为异步MySQL版本,支持事务处理和级联删除。现在用户可以正常访问销售订单页面了!

---
**修复人员**: AI Assistant  
**审核人员**: 待审核  
**状态**: ✅ 修复完成,待测试
