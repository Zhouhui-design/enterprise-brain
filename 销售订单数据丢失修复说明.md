# 销售订单数据丢失修复说明

## 问题描述

用户报告以下问题:
1. **数据丢失问题**: 点击"查看"或"编辑"按钮时,所有已录入的数据值都缺失
2. **表格字段映射不完整**: 主表格只显示部分字段,未映射订单详情页面的所有字段

## 问题根源分析

### 1. 数据丢失根本原因

**症状**: 
- 新增订单保存成功后,点击"查看"或"编辑"按钮,表单数据全部为空
- 后端已正确保存数据到数据库

**根本原因**:
```javascript
// ❌ 错误代码 - 只传递表格行数据
const handleView = (row) => {
  currentOrder.value = { ...row }  // row只包含表格显示的字段
  viewDialogVisible.value = true
}

const handleEdit = (row) => {
  currentOrder.value = { ...row }  // row不是完整的订单数据
  editDialogVisible.value = true
}
```

表格的row对象只包含用于显示的字段(如`internalOrderNo`, `customerName`等),并不包含完整的订单数据(如产品明细、回款计划等)。

### 2. 字段映射不完整

**症状**: 后端返回下划线格式字段名,前端表格期望驼峰格式

**根本原因**:
```javascript
// ❌ 只映射了部分字段
tableData.value = orders.map(order => ({
  id: order.id,
  internalOrderNo: order.internal_order_no,
  customerName: order.customer_name,
  // 缺少大量字段映射...
}))
```

## 解决方案

### 修复1: handleView - 传递订单ID而非完整数据

**文件**: `07-frontend/src/pages/sales/sales-order/SalesOrderListNew.vue`

```javascript
// ✅ 修复后 - 只传递ID,由查看组件自行加载
const handleView = async (row) => {
  currentOrder.value = { id: row.id }
  viewDialogVisible.value = true
}
```

**说明**: 
- `SalesOrderView`组件已设计为接收`orderId` prop
- 组件内部会调用API获取完整的订单数据、产品明细和回款计划

### 修复2: handleEdit - 从后端重新获取完整数据

**文件**: `07-frontend/src/pages/sales/sales-order/SalesOrderListNew.vue`

```javascript
// ✅ 修复后 - 从后端获取完整数据
const handleEdit = async (row) => {
  try {
    const response = await salesOrderApi.getSalesOrderById(row.id)
    if (response.data && response.data.success) {
      currentOrder.value = response.data.data
      editDialogVisible.value = true
    } else {
      ElMessage.error('获取订单详情失败')
    }
  } catch (error) {
    console.error('❌ 获取订单详情失败:', error)
    ElMessage.error('获取订单详情失败')
  }
}
```

### 修复3: SalesOrderCreate组件支持编辑模式

**文件**: `07-frontend/src/pages/sales/sales-order/SalesOrderCreate.vue`

#### 3.1 添加props接收订单数据

```javascript
// ✅ 接收props - 支持编辑模式
const props = defineProps({
  orderData: {
    type: Object,
    default: null
  }
})
```

#### 3.2 添加watch监听orderData变化

```javascript
// ✅ 监听orderData变化 - 编辑模式下加载完整数据
watch(
  () => props.orderData,
  async (newOrderData) => {
    if (newOrderData && newOrderData.id) {
      try {
        // 1. 加载订单主信息
        const response = await salesOrderApi.getOrderDetail(newOrderData.id)
        if (response.data.success) {
          const order = response.data.data
          
          // 2. 填充基本信息到formData
          Object.assign(formData, {
            id: order.id,
            internalOrderNo: order.internal_order_no,
            customerOrderNo: order.customer_order_no,
            customerName: order.customer_name,
            // ... 所有字段
          })
          
          // 3. 加载产品明细
          const productsResponse = await salesOrderApi.getOrderProducts(order.id)
          formData.products = productsResponse.data.data.map(p => ({
            productCode: p.product_code,
            productName: p.product_name,
            // ... 其他产品字段
          }))
          
          // 4. 加载回款计划
          const paymentsResponse = await salesOrderApi.getOrderPayments(order.id)
          formData.paymentSchedule = paymentsResponse.data.data.map(p => ({
            plannedDate: p.payment_date,
            plannedAmount: p.payment_amount,
            remark: p.remark
          }))
        }
      } catch (error) {
        console.error('❌ 加载订单数据失败:', error)
        ElMessage.error('加载订单数据失败')
      }
    }
  },
  { immediate: true }
)
```

#### 3.3 修改保存逻辑支持更新

```javascript
// ✅ 判断是创建还是更新
try {
  let response
  if (formData.id) {
    // 编辑模式 - 更新订单
    response = await salesOrderApi.updateSalesOrder(formData.id, orderData)
    console.log('✅ 订单更新成功:', response.data.data)
  } else {
    // 创建模式 - 新增订单
    response = await salesOrderApi.createSalesOrder(orderData)
    console.log('✅ 订单创建成功:', response.data.data)
  }
  
  if (response.data.success) {
    return true
  }
} catch (error) {
  console.error('❌ 保存订单失败:', error)
  return false
}
```

### 修复4: 完善表格字段映射

**文件**: `07-frontend/src/pages/sales/sales-order/SalesOrderListNew.vue`

```javascript
// ✅ 完整字段映射
const loadOrders = async () => {
  try {
    const response = await salesOrderApi.getSalesOrders({
      page: currentPage.value,
      pageSize: pageSize.value
    })
    
    if (response.data.success) {
      const orders = response.data.data.list
      tableData.value = orders.map(order => ({
        // 基本信息
        id: order.id,
        internalOrderNo: order.internal_order_no,
        customerOrderNo: order.customer_order_no,
        customerName: order.customer_name,
        customerId: order.customer_id,
        salesperson: order.salesperson,
        quotationNo: order.quotation_no,
        orderType: order.order_type,
        orderStatus: order.status || '待下单',
        
        // 时间信息
        orderTime: order.order_time,
        promisedDelivery: order.promised_delivery,
        customerDelivery: order.customer_delivery,
        estimatedCompletionDate: order.estimated_completion_date,
        createTime: new Date(order.created_at).toLocaleString('zh-CN'),
        updateTime: order.updated_at ? new Date(order.updated_at).toLocaleString('zh-CN') : null,
        
        // 销售部门和物流信息
        salesDepartment: order.sales_department,
        deliveryMethod: order.delivery_method,
        returnOrderNo: order.return_order_no,
        
        // 金额信息
        orderCurrency: order.order_currency,
        currentExchangeRate: order.current_exchange_rate,
        taxRate: order.tax_rate,
        totalAmountExcludingTax: order.total_amount_excluding_tax,
        totalAmountIncludingTax: order.total_amount_including_tax,
        totalAmount: order.total_amount,
        
        // 附件和说明
        orderAttachment: order.order_attachment,
        orderNotes: order.order_notes,
        
        // 包装信息
        packagingMethod: order.packaging_method,
        packagingRequirements: order.packaging_requirements,
        packagingAttachment: order.packaging_attachment,
        
        // 收货信息
        consignee: order.consignee,
        deliveryAddress: order.delivery_address,
        billRecipient: order.bill_recipient,
        billAddress: order.bill_address,
        
        // 回款信息
        paymentMethod: order.payment_method,
        advancePaymentRatio: order.advance_payment_ratio,
        fees: order.fees,
        paymentPlan: order.payment_plan,
        totalReceivable: order.total_receivable,
        plannedPaymentDate: order.planned_payment_date,
        plannedPaymentAmount: order.planned_payment_amount,
        receivedAmount: order.received_amount || 0,
        unreceivedAmount: order.unreceived_amount || 0,
        
        // 备注
        remark: order.remark,
        
        // 完整订单数据(用于编辑和查看)
        orderDetail: order
      }))
      totalCount.value = response.data.data.total
      console.log('✅ 从后端加载订单:', tableData.value.length, '条')
    }
  } catch (error) {
    console.error('❌ 加载订单失败:', error)
    ElMessage.error('加载订单数据失败')
  }
}
```

## 数据流程

### 查看流程

```
[点击查看按钮] 
  → handleView(row) 传递{ id: row.id }
  → SalesOrderView组件接收orderId prop
  → 组件内watch监听orderId
  → 调用3个API加载数据:
     - getOrderDetail(orderId)     // 主订单信息
     - getOrderProducts(orderId)   // 产品明细
     - getOrderPayments(orderId)   // 回款计划
  → 数据填充到表单(disabled状态)
  → 用户看到完整的只读订单信息
```

### 编辑流程

```
[点击编辑按钮]
  → handleEdit(row) 调用API获取完整数据
  → currentOrder.value = response.data.data
  → SalesOrderCreate组件接收orderData prop
  → 组件内watch监听orderData
  → 调用3个API加载数据:
     - getOrderDetail(id)
     - getOrderProducts(id)
     - getOrderPayments(id)
  → 数据填充到formData
  → 用户可编辑所有字段
  → 保存时调用updateSalesOrder(id, data)
  → 更新成功后刷新表格
```

### 新增流程

```
[点击新增按钮]
  → handleCreate()
  → SalesOrderCreate组件不传orderData(为null)
  → formData使用默认空值
  → 用户录入数据
  → 保存时调用createSalesOrder(data)
  → 创建成功后刷新表格
```

## 修改文件清单

1. **`07-frontend/src/pages/sales/sales-order/SalesOrderListNew.vue`**
   - 修改`handleView`方法:只传递订单ID
   - 修改`handleEdit`方法:从后端获取完整数据
   - 修改`loadOrders`方法:完善字段映射
   - 修改查看组件prop:`order-data` → `order-id`

2. **`07-frontend/src/pages/sales/sales-order/SalesOrderCreate.vue`**
   - 添加`props`定义:接收`orderData`
   - 添加`watch`:监听`orderData`变化,加载完整数据
   - 修改`saveOrderData`:支持创建和更新两种模式
   - 导入`watch`函数

3. **已有API(无需修改)**:
   - `salesOrderApi.getOrderDetail(id)` - 获取订单主信息
   - `salesOrderApi.getOrderProducts(id)` - 获取产品明细
   - `salesOrderApi.getOrderPayments(id)` - 获取回款计划
   - `salesOrderApi.createSalesOrder(data)` - 创建订单
   - `salesOrderApi.updateSalesOrder(id, data)` - 更新订单

## 测试验证

### 测试场景1: 新增订单
1. ✅ 点击"新增"按钮
2. ✅ 录入完整订单信息(基本信息、产品明细、回款计划)
3. ✅ 点击"提交"
4. ✅ 页面自动关闭,表格刷新,新订单出现在列表中

### 测试场景2: 查看订单
1. ✅ 点击订单的"查看"按钮
2. ✅ 查看页面打开,显示完整订单信息
3. ✅ 所有字段都为disabled状态(只读)
4. ✅ 产品明细表格显示正确
5. ✅ 回款计划表格显示正确

### 测试场景3: 编辑订单
1. ✅ 点击订单的"编辑"按钮
2. ✅ 编辑页面打开,所有已录入数据正确显示
3. ✅ 基本信息、产品明细、回款计划都完整加载
4. ✅ 修改部分字段
5. ✅ 点击"提交"保存
6. ✅ 页面关闭,表格刷新,修改生效

### 测试场景4: 表格字段映射
1. ✅ 主表格显示所有订单详情页面的字段
2. ✅ 下划线格式字段正确转换为驼峰格式
3. ✅ 金额、日期等特殊字段正确格式化显示

## 关键技术点

### 1. 下划线与驼峰命名转换

**后端数据库字段**(下划线):
```
internal_order_no
customer_order_no
customer_name
total_amount_excluding_tax
```

**前端表格字段**(驼峰):
```
internalOrderNo
customerOrderNo
customerName
totalAmountExcludingTax
```

### 2. 组件通信模式

- **查看页面**: 接收`orderId`,自行加载数据
- **编辑页面**: 接收`orderData`,watch监听并加载完整数据
- **新增页面**: 不传props,使用空formData

### 3. API调用策略

编辑/查看时需要调用3个API:
1. `getOrderDetail(id)` - 获取主订单
2. `getOrderProducts(id)` - 获取产品明细(关联表)
3. `getOrderPayments(id)` - 获取回款计划(关联表)

这是因为订单数据存储在3个表中:
- `sales_orders` - 主订单表
- `sales_order_products` - 产品明细表
- `sales_order_payment_schedule` - 回款计划表

## 总结

本次修复解决了两个核心问题:

1. **数据丢失问题**: 通过从后端重新获取完整数据,而非依赖表格行数据
2. **字段映射不完整**: 补全所有字段的下划线→驼峰转换映射

修复后,用户可以:
- ✅ 正常查看订单的所有信息
- ✅ 正常编辑订单并保留所有已录入数据
- ✅ 在主表格看到完整的订单字段

所有修改遵循Vue 3 Composition API最佳实践,确保代码可维护性和性能。
