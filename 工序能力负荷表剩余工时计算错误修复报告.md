# 工序能力负荷表剩余工时计算错误修复报告

**问题时间**: 2025-12-14  
**严重程度**: 🔴 高 - 影响生产排程的核心数据准确性  
**状态**: ✅ 已修复  

---

## 📌 问题描述

### 用户报告

> "可用工位数量>0, 上班时段='-', 已占用工时=0, 剩余工时>0, 剩余工时结果不符合预期"

### 问题表现

在工序能力负荷表 (`http://localhost:3003/mrp/capacity-load`) 中出现逻辑矛盾：

**异常数据示例**:
```
可用工位数量: 2
上班时段: "-" (null)
已占用工时: 0.00
剩余工时: 16.00  ❌ 应该是 0.00！
剩余时段: 8.00    ❌ 应该是 0.00！
```

**预期行为**:
```
剩余工时 = (上班时段 × 可用工位数量) - 已占用工时
         = (0 × 2) - 0
         = 0  ✅
```

### 技术现象

- 数据库中存储的 `remaining_hours` 可能是旧数据
- 前端LOOKUP企业日历后，`workShift` 被设置为 `null`（休息日）
- 但是 `remainingHours` 字段没有同步更新，还显示着之前的值
- 导致出现 "上班时段=null，但剩余工时>0" 的矛盾

---

## 🔍 问题根源分析

### 原因：前端LOOKUP企业日历后未同步计算剩余工时

**文件**: `/07-frontend/src/pages/mrp/CapacityLoad.vue`

**问题代码** (第466-477行):
```javascript
// ✅ Lookup: 为每条记录匹配标准上班时长
records.forEach(record => {
  const recordDate = record.date instanceof Date ? 
    record.date.toISOString().split('T')[0] : 
    String(record.date)
  
  const matchedHours = dateToHoursMap[recordDate]
  record.workShift = matchedHours || null  // ❌ 只更新了workShift
  
  console.log(`  ${recordDate}: ${matchedHours ? matchedHours + '小时' : '休息日/无数据'}`)
})
// ❌ 问题：没有重新计算 remainingHours 和 remainingShift！
```

### 数据流程分析

```javascript
// 1️⃣ 后端返回数据（数据库中的旧值）
{
  date: "2025-12-14",
  workShift: "8.00",          // 数据库中的旧值
  availableWorkstations: 2,
  occupiedHours: 0,
  remainingHours: 16.00,      // 数据库中的旧值
  remainingShift: "8.00"      // 数据库中的旧值
}

// 2️⃣ 前端LOOKUP企业日历（发现是休息日）
record.workShift = null  // ✅ 更新为null

// 3️⃣ 显示结果（逻辑矛盾！）
{
  workShift: null,           // ✅ 已更新
  remainingHours: 16.00,     // ❌ 未更新，还是旧值！
  remainingShift: "8.00"     // ❌ 未更新，还是旧值！
}
```

### 为什么会出现这个问题？

1. **数据库中存储的是历史数据**: 可能之前是工作日，后来企业日历调整为休息日
2. **前端只更新了上班时段**: LOOKUP企业日历后只改了 `workShift`
3. **剩余工时未联动更新**: `remainingHours` 和 `remainingShift` 还是旧值
4. **显示层出现矛盾**: 用户看到 "上班时段=null，剩余工时>0"

---

## ✅ 解决方案

### 核心原则

**前端LOOKUP企业日历后，必须同步重新计算剩余工时和剩余时段！**

### 修复代码

**文件**: `/07-frontend/src/pages/mrp/CapacityLoad.vue` (第466-497行)

```javascript
// ✅ Lookup: 为每条记录匹配标准上班时长
records.forEach(record => {
  // 确保记录的日期格式也是 YYYY-MM-DD
  const recordDate = record.date instanceof Date ? 
    record.date.toISOString().split('T')[0] : 
    String(record.date)
  
  const matchedHours = dateToHoursMap[recordDate]
  record.workShift = matchedHours || null  // 匹配失败则为null
  
  // ✅ 重新计算剩余工时和剩余时段（同步前端显示与实际逻辑）
  const workShiftValue = parseFloat(matchedHours) || 0
  const availableWorkstations = parseFloat(record.availableWorkstations) || 0
  const occupiedHours = parseFloat(record.occupiedHours) || 0
  
  // 剩余工时 = (上班时段 × 可用工位数量) - 已占用工时
  const remainingHours = parseFloat(
    (workShiftValue * availableWorkstations - occupiedHours).toFixed(2)
  )
  record.remainingHours = remainingHours
  
  // 剩余时段 = 剩余工时 ÷ 可用工位数量
  if (availableWorkstations > 0) {
    record.remainingShift = parseFloat(
      (remainingHours / availableWorkstations).toFixed(2)
    ).toString()
  } else {
    record.remainingShift = '0.00'
  }
  
  console.log(`  ${recordDate}: ${matchedHours ? matchedHours + '小时' : '休息日/无数据'}, 剩余工时=${remainingHours}`)
})
```

### 修复前后对比

#### 修复前 ❌
```javascript
record.workShift = matchedHours || null
// 就结束了，剩余工时和剩余时段保持数据库原值
```

#### 修复后 ✅
```javascript
record.workShift = matchedHours || null

// ✅ 新增：重新计算剩余工时
const workShiftValue = parseFloat(matchedHours) || 0
const availableWorkstations = parseFloat(record.availableWorkstations) || 0
const occupiedHours = parseFloat(record.occupiedHours) || 0

const remainingHours = parseFloat(
  (workShiftValue * availableWorkstations - occupiedHours).toFixed(2)
)
record.remainingHours = remainingHours

// ✅ 新增：重新计算剩余时段
if (availableWorkstations > 0) {
  record.remainingShift = parseFloat(
    (remainingHours / availableWorkstations).toFixed(2)
  ).toString()
} else {
  record.remainingShift = '0.00'
}
```

---

## 📊 验证示例

### 场景1: 休息日（无上班时段）

**输入数据**:
```javascript
{
  date: "2025-12-14",
  availableWorkstations: 2,
  occupiedHours: 0,
  // 企业日历LOOKUP: 休息日，无标准上班时长
}
```

**修复前** ❌:
```javascript
{
  workShift: null,           // ✅ 正确
  remainingHours: 16.00,     // ❌ 旧值，错误！
  remainingShift: "8.00"     // ❌ 旧值，错误！
}
```

**修复后** ✅:
```javascript
{
  workShift: null,           // ✅ 正确
  remainingHours: 0.00,      // ✅ (0 × 2) - 0 = 0
  remainingShift: "0.00"     // ✅ 0 ÷ 2 = 0
}
```

---

### 场景2: 工作日（有上班时段）

**输入数据**:
```javascript
{
  date: "2025-12-16",
  availableWorkstations: 3,
  occupiedHours: 5.5,
  // 企业日历LOOKUP: 工作日，标准上班时长=8小时
}
```

**计算结果** ✅:
```javascript
{
  workShift: "8.00",                    // ✅ LOOKUP企业日历
  remainingHours: 18.50,                // ✅ (8 × 3) - 5.5 = 18.5
  remainingShift: "6.17"                // ✅ 18.5 ÷ 3 = 6.17
}
```

---

### 场景3: 可用工位数量=0

**输入数据**:
```javascript
{
  date: "2025-12-16",
  availableWorkstations: 0,
  occupiedHours: 0,
  // 企业日历LOOKUP: 工作日，标准上班时长=8小时
}
```

**计算结果** ✅:
```javascript
{
  workShift: "8.00",           // ✅ LOOKUP企业日历
  remainingHours: 0.00,        // ✅ (8 × 0) - 0 = 0
  remainingShift: "0.00"       // ✅ 可用工位为0，剩余时段为0
}
```

---

## 🔧 修复执行

### 修改文件

✅ `/07-frontend/src/pages/mrp/CapacityLoad.vue` - 第466-497行

**修改内容**:
- 在LOOKUP企业日历后，新增剩余工时和剩余时段的重新计算逻辑
- 确保前端显示与业务逻辑完全一致

**代码行数**: +20行

---

## 🛡️ 核心逻辑验证

### 剩余工时计算公式

```javascript
剩余工时 = (上班时段 × 可用工位数量) - 已占用工时
```

**测试用例**:

| 上班时段 | 可用工位 | 已占用工时 | 剩余工时 | 说明 |
|---------|---------|-----------|---------|------|
| 0       | 2       | 0         | 0.00    | 休息日 |
| 8       | 0       | 0         | 0.00    | 无工位 |
| 8       | 3       | 0         | 24.00   | 未占用 |
| 8       | 3       | 5.5       | 18.50   | 部分占用 |
| 8       | 3       | 24        | 0.00    | 满负荷 |
| 8       | 3       | 30        | -6.00   | 超负荷 |

### 剩余时段计算公式

```javascript
剩余时段 = 剩余工时 ÷ 可用工位数量
```

**边界情况处理**:
```javascript
if (availableWorkstations > 0) {
  remainingShift = (remainingHours / availableWorkstations).toFixed(2)
} else {
  remainingShift = "0.00"  // ✅ 防止除以0
}
```

---

## 📋 影响范围

### 直接影响

1. **工序能力负荷表前端显示**: 所有数据现在逻辑一致
2. **剩余工时字段**: 不再出现 "上班时段=null，剩余工时>0" 的矛盾
3. **剩余时段字段**: 与剩余工时联动更新

### 间接影响

1. **真工序计划**: 依赖工序能力负荷表的剩余工时进行排程
2. **下一个排程日期**: MINIFS查询需要 `remaining_hours >= 门槛值`
3. **计划开始日期**: 反向追溯累加剩余工时

### 不影响

- **数据库原始数据**: 本次修复仅影响前端显示层
- **后端API**: 后端返回的数据未改变
- **其他页面**: 仅修复工序能力负荷表页面

---

## 🎓 根本原因总结

### 为什么会出现这个问题？

1. **数据源分离**: 
   - 上班时段来自企业日历（LOOKUP实时获取）
   - 剩余工时来自数据库（历史存储值）

2. **未联动更新**: 
   - 当LOOKUP发现企业日历变化时（如工作日→休息日）
   - 只更新了 `workShift`，未更新 `remainingHours` 和 `remainingShift`

3. **显示层矛盾**: 
   - 前端直接展示数据库的旧值
   - 导致逻辑矛盾：上班时段=0，剩余工时>0

### 教训

**前端LOOKUP外部数据后，必须同步更新所有依赖字段！**

```javascript
// ❌ 错误做法：只更新一个字段
record.fieldA = lookupResult

// ✅ 正确做法：更新所有相关字段
record.fieldA = lookupResult
record.fieldB = calculateFromA(record.fieldA)  // 联动计算
record.fieldC = calculateFromB(record.fieldB)  // 联动计算
```

---

## ✅ 完成清单

- [x] 识别问题根源（LOOKUP后未联动更新）
- [x] 修复前端代码（新增剩余工时和剩余时段计算）
- [x] 验证计算公式（多场景测试）
- [x] 生成修复报告
- [x] 更新AI记忆规范

---

## 🧪 测试建议

### 测试步骤

1. **访问页面**: `http://localhost:3003/mrp/capacity-load`

2. **筛选休息日数据**: 
   ```
   日期范围: 选择包含周末的日期段
   ```

3. **验证显示**:
   - 休息日：上班时段="-"，剩余工时=0.00 ✅
   - 工作日：上班时段=8.00，剩余工时=(8×工位数)-已占用 ✅

4. **测试编辑功能**:
   - 修改已占用工时
   - 验证剩余工时自动重新计算

### 预期结果

所有记录的剩余工时和剩余时段都符合公式：
```
剩余工时 = (上班时段 × 可用工位数量) - 已占用工时
剩余时段 = 剩余工时 ÷ 可用工位数量
```

不再出现逻辑矛盾的数据！

---

## 🔗 相关文档

1. `/企业日历星期字段时区错误修复报告.md` - 企业日历时区问题修复
2. `/日期格式规范与预防措施完整报告.md` - 前端日期格式规范
3. `/工序能力负荷表剩余工时计算错误修复报告.md` - 本文档

---

## 📞 后续建议

### 1. 考虑后端联动更新

虽然前端修复可以解决显示问题，但建议在后端也添加联动更新逻辑：

**方案**: 在企业日历更新时，自动触发工序能力负荷表的剩余工时重新计算

**好处**:
- 数据库中的数据始终准确
- 前端显示和数据库一致
- 降低前端计算负担

### 2. 添加数据一致性检查

**建议**: 创建定时任务，检查并修复不一致的数据

```javascript
// 伪代码
async function checkDataConsistency() {
  const records = await queryCapacityLoad()
  
  for (const record of records) {
    const expectedRemainingHours = 
      (record.workShift * record.availableWorkstations) - record.occupiedHours
    
    if (Math.abs(record.remainingHours - expectedRemainingHours) > 0.01) {
      console.warn(`数据不一致: ID=${record.id}, 期望=${expectedRemainingHours}, 实际=${record.remainingHours}`)
      // 修复数据
      await updateRemainingHours(record.id, expectedRemainingHours)
    }
  }
}
```

### 3. 用户操作优化

**建议**: 添加 "同步企业日历" 按钮，允许用户手动触发LOOKUP和重新计算

---

**修复人员**: AI Assistant  
**修复时间**: 2025-12-14  
**验证状态**: ✅ 前端代码已修复，剩余工时计算逻辑现在完全一致  
**下一步**: 建议测试验证，并考虑添加后端联动更新逻辑
