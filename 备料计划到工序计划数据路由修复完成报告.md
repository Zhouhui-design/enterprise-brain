# 备料计划到工序计划数据路由修复完成报告

## 📋 问题概述

用户报告了一个关键问题：备料计划中"来源工序"=组装的数据被错误地推送到了打包工序计划（real_process_plans），而根据文档规范，应该推送到组装工序计划（assembly_process_plans）。

## 🎯 修复目标

1. **路由修复**：根据来源工序正确路由数据
   - 来源工序="组装" → assembly_process_plans 表
   - 来源工序="打包" → real_process_plans 表
   - 未知来源工序 → 跳过推送

2. **字段修复**：确保数据库字段映射正确

3. **代码优化**：清理重复代码，提升可维护性

## 🔧 修复内容

### 1. 核心路由逻辑实现

**文件位置**：`backend/services/materialPreparationPlanService.js`

#### 1.1 修改 create 方法（第240-260行）
```javascript
// ✅ 根据来源工序判断推送到哪个工序计划表
const sourceProcess = data.sourceProcess || data.source_process || '';
if (sourceProcess === '组装') {
  // 推送到组装工序计划
  console.log('🎯 路由到组装工序计划 (assembly_process_plans)');
  await this.pushToAssemblyProcessPlan(connection, data, replenishmentQty);
} else if (sourceProcess === '打包') {
  // 推送到打包工序计划
  console.log('🎯 路由到打包工序计划 (real_process_plans)');
  await this.pushToPackingProcessPlan(connection, data, replenishmentQty);
} else {
  console.log(`⚠️ 未知来源工序: ${sourceProcess}，跳过推送`);
}
```

#### 1.2 新增 pushToAssemblyProcessPlan 方法（第479-577行）
- 专门处理组装工序计划的数据推送
- 正确映射 `assembly_process_plans` 表的字段
- 生成组装工序计划编号（ASP前缀）
- 包含完整的错误处理和日志记录

#### 1.3 新增 pushToPackingProcessPlan 方法（第582-680行）
- 专门处理打包工序计划的数据推送
- 正确映射 `real_process_plans` 表的字段
- 生成打包工序计划编号（RPP前缀）
- 包含完整的错误处理和日志记录

#### 1.4 更新 pushToRealProcessPlan 方法（第452-467行）
- 修改为路由分发逻辑，不再直接插入数据
- 根据来源工序调用相应的推送方法
- 保持向后兼容性

### 2. 数据库字段映射修复

#### 2.1 assembly_process_plans 表字段修复
**问题**：使用了错误的字段名 `main_plan_product_code`  
**修复**：改为正确的字段名 `master_plan_product_code`

```javascript
// 修复前（错误）
INSERT INTO assembly_process_plans (
  main_plan_product_code, main_plan_product_name, ...
)

// 修复后（正确）
INSERT INTO assembly_process_plans (
  master_plan_product_code, master_plan_product_name, ...
)
```

#### 2.2 日期字段修复
- 修复了 `promise_delivery_date` 字段在 assembly_process_plans 表中对应的 `order_promise_delivery_date` 字段

### 3. 代码清理

#### 3.1 删除重复代码
- 移除了 lines 468-792 的重复和过时代码
- 统一了数据推送流程

#### 3.2 日志优化
- 添加了清晰的路由标识（🎯 emoji）
- 包含详细的推送过程日志
- 区分了不同工序计划的处理结果

## 🧪 测试验证

### 测试场景1：来源工序 = 组装
```javascript
const assemblyData = {
  sourceProcess: '组装',
  materialCode: '6001A0306',
  // ... 其他字段
};
// 期望：推送到 assembly_process_plans 表
// 结果：✅ 正确路由
```

### 测试场景2：来源工序 = 打包
```javascript
const packingData = {
  sourceProcess: '打包',
  materialCode: '6001A0306',
  // ... 其他字段
};
// 期望：推送到 real_process_plans 表
// 结果：✅ 正确路由
```

### 测试场景3：未知来源工序
```javascript
const unknownData = {
  sourceProcess: '未知工序',
  // ... 其他字段
};
// 期望：跳过推送
// 结果：✅ 正确跳过
```

## 📊 数据流向

```
备料计划 (material_preparation_plans)
    ↓
检查 sourceProcess 字段
    ↓
┌─────────────────┬─────────────────┐
│ sourceProcess   │ 目标表          │
├─────────────────┼─────────────────┤
│ "组装"          │ assembly_process_plans │
│ "打包"          │ real_process_plans    │
│ 其他           │ 跳过推送        │
└─────────────────┴─────────────────┘
```

## 🎯 核心改进

### 1. 精确路由
- 基于 `sourceProcess` 字段进行精确路由
- 避免了数据流向错误的问题
- 符合业务文档规范

### 2. 错误隔离
- 不同工序计划的处理逻辑隔离
- 一个工序计划出错不影响其他
- 详细的错误日志便于调试

### 3. 可维护性
- 清晰的方法职责划分
- 统一的数据处理模式
- 易于扩展新的工序类型

### 4. 向后兼容
- 保持现有API接口不变
- 现有的调用方式继续有效
- 平滑过渡，无破坏性变更

## 📝 使用说明

### 创建备料计划时自动路由
```javascript
const result = await MaterialPreparationPlanService.create(planData);
// 系统会根据 planData.sourceProcess 自动推送到对应表
```

### 手动推送时自动路由
```javascript
const result = await MaterialPreparationPlanService.pushToRealProcessPlan(planData);
// 系统会根据 planData.sourceProcess 自动路由
```

## 🎉 修复完成

✅ **问题已完全解决**
- 来源工序="组装" 的备料计划数据现在正确推送到 `assembly_process_plans` 表
- 来源工序="打包" 的备料计划数据继续推送到 `real_process_plans` 表
- 未知来源工序的备料计划会跳过推送并记录警告日志
- 数据库字段映射错误已修复
- 重复代码已清理

✅ **质量保证**
- 所有测试场景验证通过
- 错误处理机制完善
- 日志记录清晰完整
- 代码结构清晰可维护

## 📞 后续建议

1. **监控观察**：建议在上线后观察几天，确认数据流向正确
2. **日志检查**：定期检查推送日志，确认路由行为符合预期
3. **业务验证**：与业务部门确认组装工序计划和打包工序计划的数据正确性
4. **文档更新**：如有需要，更新相关技术文档和用户手册

---

**修复完成时间**：2025年12月14日  
**修复文件**：`backend/services/materialPreparationPlanService.js`  
**测试状态**：✅ 全部通过  
**部署状态**：✅ 就绪