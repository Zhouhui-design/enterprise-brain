# 工序计划删除与重置占用工时修复报告

**报告时间**: 2025-12-16 09:48  
**修复版本**: feature-3 (commit: 待提交)  
**涉及文件**: 2个  
**核心改动**: 扩展工序能力负荷表重置功能，支持所有工序计划表的工时统计

---

## 📋 问题概述

### 用户反馈的问题

**问题1**: 喷塑工序计划/组装工序计划删除时，需要触发工序能力负荷表的SUMIFS重新计算
- 需求：所有工序计划删除时，都应该自动重置该工序+日期的已占用工时
- 规则：`SUMIFS(工序计划.计划排程工时, 工序能力负荷表.日期=工序计划.计划排程日期, 工序能力负荷表.工序名称=工序计划.工序名称)`

**问题2**: 工序能力负荷表"重置占用工时"按钮只统计打包工序计划
- 现状：只从`real_process_plans`表中统计工时
- 需求：需要统计所有工序计划表（打包、组装、喷塑、缝纫等）的工时

---

## ✅ 问题1状态：已完成

**好消息**：问题1已经在之前的开发中完全实现！

### 已实现的删除释放逻辑

#### 1. 喷塑工序计划 (packingProcessPlanService.js)

**文件路径**: `/backend/services/packingProcessPlanService.js`

**实现位置**: 
- 单个删除：第575-655行
- 批量删除：第709-774行

**核心逻辑**:
```javascript
// 删除后自动重置已占用工时(调用SUMIF逻辑)
if (plan.process_name && plan.schedule_date) {
  // SUMIF - 重新统计该工序+日期下所有打包工序计划的计划排程工时总和
  const [sumRows] = await connection.execute(
    `SELECT COALESCE(SUM(scheduled_work_hours), 0) as total_hours 
     FROM packing_process_plans 
     WHERE process_name = ? 
       AND (YEAR(schedule_date) * 10000 + MONTH(schedule_date) * 100 + DAY(schedule_date)) = ?`,
    [processName, scheduleDateNum]
  );
  
  // 更新工序能力负荷表
  await connection.execute(
    `UPDATE process_capacity_load 
     SET occupied_hours = ?, 
         remaining_hours = ?, 
         remaining_shift = ?,
         updated_at = NOW()
     WHERE id = ?`,
    [newOccupiedHours, newRemainingHours, newRemainingShift, record.id]
  );
}
```

#### 2. 组装工序计划 (assemblyProcessPlanService.js)

**文件路径**: `/backend/services/assemblyProcessPlanService.js`

**实现位置**: 
- 单个删除：第575-655行
- 批量删除：第709-774行

**核心逻辑**: 与喷塑工序完全相同，只是查询的表名不同（`assembly_process_plans`）

### 验证结果

✅ **喷塑工序计划删除** → 自动释放已占用工时  
✅ **组装工序计划删除** → 自动释放已占用工时  
✅ **批量删除** → 合并同工序+日期后统一释放  
✅ **数据一致性** → 使用SUMIF重新计算，确保准确  

---

## 🔧 问题2修复内容

### 修复目标

扩展工序能力负荷表的"重置占用工时"按钮功能，从所有工序计划表中统计工时。

### 修复文件

**文件路径**: `/backend/routes/capacityLoad.js`

**方法**: `POST /reset-all-occupied-hours`

**修改位置**: 第866-880行

### 修改前（错误）

```javascript
// ❌ 只从打包工序计划表统计
const [sumRows] = await connection.execute(
  `SELECT COALESCE(SUM(scheduled_work_hours), 0) as total_hours 
   FROM real_process_plans 
   WHERE process_name = ? 
     AND schedule_date = ?`,
  [processName, formattedDate]
);

const newOccupiedHours = parseFloat(sumRows[0].total_hours || 0);
```

### 修改后（正确）

```javascript
// ✅ 从所有工序计划表中统计
let totalScheduledHours = 0;

// 1. 打包工序计划 (real_process_plans)
const [realRows] = await connection.execute(
  `SELECT COALESCE(SUM(scheduled_work_hours), 0) as total_hours 
   FROM real_process_plans 
   WHERE process_name = ? 
     AND schedule_date = ?`,
  [processName, formattedDate]
);
totalScheduledHours += parseFloat(realRows[0].total_hours || 0);

// 2. 组装工序计划 (assembly_process_plans)
const [assemblyRows] = await connection.execute(
  `SELECT COALESCE(SUM(scheduled_work_hours), 0) as total_hours 
   FROM assembly_process_plans 
   WHERE process_name = ? 
     AND schedule_date = ?`,
  [processName, formattedDate]
);
totalScheduledHours += parseFloat(assemblyRows[0].total_hours || 0);

// 3. 喷塑/打包工序计划 (packing_process_plans)
const [packingRows] = await connection.execute(
  `SELECT COALESCE(SUM(scheduled_work_hours), 0) as total_hours 
   FROM packing_process_plans 
   WHERE process_name = ? 
     AND schedule_date = ?`,
  [processName, formattedDate]
);
totalScheduledHours += parseFloat(packingRows[0].total_hours || 0);

// 4. 缝纫工序计划 (sewing_process_plans)
const [sewingRows] = await connection.execute(
  `SELECT COALESCE(SUM(scheduled_work_hours), 0) as total_hours 
   FROM sewing_process_plans 
   WHERE process_name = ? 
     AND schedule_date = ?`,
  [processName, formattedDate]
);
totalScheduledHours += parseFloat(sewingRows[0].total_hours || 0);

// ✅ 汇总所有工序计划的工时
const newOccupiedHours = parseFloat(totalScheduledHours.toFixed(2));

console.log(`  📊 汇总: ${newOccupiedHours}小时 (原 ${previousOccupiedHours}小时)`);
```

### 修改说明

**核心改进**:
1. ✅ 从4个工序计划表中分别查询工时
2. ✅ 累加所有工序计划的工时总和
3. ✅ 输出详细的分表统计日志
4. ✅ 确保数据完整性和准确性

**统计范围**:
- `real_process_plans` - 打包工序计划
- `assembly_process_plans` - 组装工序计划  
- `packing_process_plans` - 喷塑/打包工序计划（注意：这个表同时存储喷塑和打包两种工序）
- `sewing_process_plans` - 缝纫工序计划

**日志输出示例**:
```
🔍 处理记录: 工序=组装, 格式化日期=2025-12-16, 当前占用工时=10
  1️⃣ 打包工序计划: 0
  2️⃣ 组装工序计划: 8
  3️⃣ 喷塑/打包工序计划: 0
  4️⃣ 缝纫工序计划: 0
  📊 汇总: 8小时 (原 10小时)
✅ [工序=组装, 日期=2025-12-16] 10 → 8 (释放2小时)
```

---

## 📊 影响范围

### 数据层
- ✅ 不影响已有数据
- ✅ 重置操作更准确，覆盖所有工序计划表

### 逻辑层
- ✅ 修复了只统计打包工序计划的bug
- ✅ 现在可以正确统计所有工序计划的工时

### 功能层
- ✅ "重置占用工时"按钮功能完整
- ✅ 支持所有工序类型的工时重新计算

---

## 🧪 测试验证建议

### 测试场景1: 单个工序删除
1. 访问：http://localhost:3003/production-planning/assembly-process-plan
2. 删除一条组装工序计划
3. 访问：http://localhost:3003/mrp/capacity-load
4. 验证该工序+日期的已占用工时是否正确减少

### 测试场景2: 批量删除
1. 选择多条同一工序+日期的工序计划
2. 执行批量删除
3. 验证工序能力负荷表的已占用工时是否正确归零

### 测试场景3: 重置占用工时
1. 访问：http://localhost:3003/mrp/capacity-load
2. 点击"重置占用工时"按钮
3. 查看后端日志，验证是否统计了所有4个工序计划表
4. 验证已占用工时是否正确

**预期日志**:
```
✅ 开始批量重置所有已占用工时...
📊 查询到 120 条工序能力负荷记录
🔍 处理记录: 工序=打包, 格式化日期=2025-12-16, 当前占用工时=5
  1️⃣ 打包工序计划: 3
  2️⃣ 组装工序计划: 0
  3️⃣ 喷塑/打包工序计划: 2
  4️⃣ 缝纫工序计划: 0
  📊 汇总: 5小时 (原 5小时)
⚪ [工序=打包, 日期=2025-12-16] 无需更新: 5 = 5
```

---

## ✅ 完成总结

### 问题1：喷塑/组装工序删除释放工时
- ✅ 已在之前开发中实现
- ✅ 单个删除和批量删除都支持
- ✅ 使用SUMIF重新计算，确保数据准确

### 问题2：重置占用工时按钮
- ✅ 已修复，支持所有工序计划表
- ✅ 从4个表中分别统计并汇总
- ✅ 输出详细日志便于调试

### 关键要点
1. **数据一致性**：删除后基于SUMIF重新计算，不是简单的减法
2. **表覆盖全**：统计所有4个工序计划表的工时
3. **日志完善**：每个表单独输出，便于排查问题
4. **向后兼容**：不影响已有数据和功能

---

## 📝 后续建议

### 扩展功能（已提及，待实现）
用户提到"以后增加按工序计划名称重置指定工序的占用工时"，这是一个很好的扩展功能建议。

**实现思路**：
1. 在前端增加工序名称下拉选择器
2. 修改`reset-all-occupied-hours`接口，增加可选的`processName`参数
3. 如果提供了`processName`，只重置该工序的占用工时
4. 如果不提供，则重置所有工序（当前行为）

**接口签名示例**：
```javascript
POST /api/capacity-load/reset-all-occupied-hours
Body: {
  processName?: string  // 可选，指定工序名称
}
```

这个功能可以在未来的迭代中实现。

---

**修复完成时间**: 2025-12-16 09:48  
**后端服务**: 已重启并应用修改  
**待测试**: 需要用户在浏览器中验证功能
