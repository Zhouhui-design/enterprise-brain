# 备料计划到工序计划数据流规则修复报告

**修复时间**: 2025-12-15 09:50  
**修复原因**: 根据规则文档,应使用"来源工序"而非"产出工序"进行路由  
**修复文件**: `backend/services/materialPreparationPlanService.js`

---

## 🎯 问题分析

### 错误实现（之前）

**使用字段**: `outputProcess`（产出工序,从产品物料库的`process_name`字段查询）

```javascript
// ❌ 错误做法
const [materialRows] = await connection.execute(
  'SELECT material_code, standard_time, quota_time, process_name FROM materials WHERE material_code = ? LIMIT 1',
  [data.materialCode]
);
outputProcess = material.process_name;  // ❌ 查询产出工序

if (outputProcess === '打包') {
  // 推送到打包工序计划
} else if (outputProcess === '组装') {
  // 推送到组装工序计划
}
```

**问题**:
- 违背了规则文档要求
- 规则文档明确说明:基于`sourceProcess`（来源工序）进行路由
- 增加了不必要的数据库查询

### 正确实现（现在）

**使用字段**: `processName = data.sourceProcess`（来源工序,直接从备料计划获取）

```javascript
// ✅ 正确做法
const [materialRows] = await connection.execute(
  'SELECT material_code, standard_time, quota_time FROM materials WHERE material_code = ? LIMIT 1',
  [data.materialCode]
);
// 不再查询process_name

const processName = data.sourceProcess;  // ✅ 直接使用来源工序

if (processName === '打包') {
  // 推送到打包工序计划
} else if (processName === '组装') {
  // 推送到组装工序计划
}
```

---

## 📝 修复内容

### 1. 移除产出工序查询

**文件**: `materialPreparationPlanService.js`  
**行号**: 893-930

**修改前**:
```javascript
const [materialRows] = await connection.execute(
  'SELECT material_code, standard_time, quota_time, process_name FROM materials WHERE material_code = ? LIMIT 1',
  [data.materialCode]
);
outputProcess = material.process_name;

if (!outputProcess) {
  console.warn(`⚠️ 产出工序为空，无法推送: 物料编号=${data.materialCode}`);
  return { success: false, reason: 'no_output_process' };
}
```

**修改后**:
```javascript
const [materialRows] = await connection.execute(
  'SELECT material_code, standard_time, quota_time FROM materials WHERE material_code = ? LIMIT 1',
  [data.materialCode]
);
// 不再查询process_name

const processName = data.sourceProcess;  // ✅ 使用来源工序

if (!processName) {
  console.warn(`⚠️ 来源工序为空，无法推送: 物料编号=${data.materialCode}`);
  return { success: false, reason: 'no_source_process' };
}
```

### 2. 更新所有使用outputProcess的地方为processName

共修改约15处引用:

| 原代码 | 新代码 | 位置 |
|-------|-------|------|
| `outputProcess` | `processName` | 第920行（检查是否为空） |
| `outputProcess` | `processName` | 第927行（检查是否支持） |
| `outputProcess` | `processName` | 第934-937行（确定检查表） |
| `outputProcess` | `processName` | 第980,991行（查询计划结束日期） |
| `outputProcess` | `processName` | 第1004,1014行（查询计划开始日期） |
| `outputProcess` | `processName` | 第1051,1058,1064,1066行（查询当天总工时） |
| `outputProcess` | `processName` | 第1075-1078行（确定目标表） |
| `outputProcess` | `processName` | 第1138行（realProcessPlanData） |
| `outputProcess` | `processName` | 第1168,1172行（路由逻辑） |
| `outputProcess` | `processName` | 第1182-1184行（日志输出） |
| `outputProcess` | `processName` | 第1208行（返回值） |

### 3. 更新日志输出

**修改前**:
```javascript
console.log(`📍 [数据路由] 产出工序=${outputProcess} → 推送到${serviceName}`);
console.log(`   备料计划的来源工序=${data.sourceProcess} (仅作记录，不用于路由)`);
```

**修改后**:
```javascript
console.log(`📍 [数据路由] 来源工序=${processName} → 推送到${serviceName} (表: ${targetTable})`);
console.log(`   备料计划编号=${data.planNo}`);
console.log(`   物料编号=${data.materialCode}, 物料名称=${data.materialName}`);
console.log(`   需补货数量=${replenishmentQty}`);
```

---

## ✅ 修复效果

### IFS条件判断（符合规则文档）

```javascript
IFS(
  AND(
    备料计划编号 != null,      // ✅ 检查通过
    需补货数量 > 0,           // ✅ 检查通过
    物料来源 = "自制",        // ✅ 检查通过
    来源工序 = "打包"         // ✅ 使用来源工序进行判断
  ) → 推送到 "打包工序计划",
  
  AND(
    备料计划编号 != null,      // ✅ 检查通过
    需补货数量 > 0,           // ✅ 检查通过
    物料来源 = "自制",        // ✅ 检查通过
    来源工序 = "组装"         // ✅ 使用来源工序进行判断
  ) → 推送到 "组装工序计划"
)
```

### 数据流执行顺序

```
主生产计划 (6001A0306)
    ↓ 执行排程
备料计划 (bl01)
  - 备料物料编号: 6001A0306
  - 来源工序: 打包  ← ✅ 使用此字段路由
  - 需补货数量: 10
  - 物料来源: 自制
    ↓ 推送到打包工序计划（根据来源工序=打包）
打包工序计划 (RPP...)
  - 生产产品编号: 6001A0306
  - 工序名称: 打包
  - 来源编号: bl01
    ↓ 推送BOM子件到备料计划
备料计划 (bl02, bl03, bl04)
  - bl02: 470001A, 来源工序=组装 ← ✅ 推送到组装工序计划
  - bl03: 470002A, 来源工序=组装 ← ✅ 推送到组装工序计划
  - bl04: 511442B, 来源工序=采购 ← ❌ 不推送
    ↓
组装工序计划 (ASP...)
  - ...递归继续
```

---

## 🔍 验证要点

### 1. 字段来源验证

| 字段 | 正确来源 | 验证SQL |
|------|---------|---------|
| `sourceProcess`（来源工序） | 备料计划表 | `SELECT source_process FROM material_preparation_plans` |
| `processName`（工序名称） | = sourceProcess | `WHERE process_name = source_process` |

### 2. 路由规则验证

| 来源工序 | 推送目标 | 验证SQL |
|---------|---------|---------|
| '打包' | packing_process_plans | `SELECT * FROM packing_process_plans WHERE source_no = 'bl01'` |
| '组装' | assembly_process_plans | `SELECT * FROM assembly_process_plans WHERE source_no = 'bl02'` |

### 3. 数据一致性验证

```sql
-- 验证备料计划的来源工序与工序计划的工序名称一致
SELECT 
  mp.plan_no,
  mp.material_code,
  mp.source_process AS '备料计划来源工序',
  pp.process_name AS '工序计划工序名称',
  CASE 
    WHEN mp.source_process = pp.process_name THEN '✅ 一致'
    ELSE '❌ 不一致'
  END AS '验证结果'
FROM material_preparation_plans mp
LEFT JOIN packing_process_plans pp ON pp.source_no = mp.plan_no
WHERE mp.material_source = '自制'
  AND mp.source_process = '打包';
```

---

## 💡 关键收获

### 1. 规则文档的重要性

- ✅ **教训**: 必须严格遵循业务规则文档
- ❌ **错误**: 擅自使用"产出工序"代替"来源工序"
- 📝 **改进**: 开发前先完整阅读规则文档

### 2. 数据一致性

**发现**:
```
备料计划.来源工序 = 产品物料库.产出工序（大部分情况下）
```

**但**:
- 存在历史数据不一致的情况
- 不能依赖这种"巧合的一致性"
- 必须严格按照规范使用字段

### 3. 性能优化

**优化点**:
- ✅ 减少了一次数据库查询（不再查询materials.process_name）
- ✅ 直接使用备料计划中已有的source_process字段
- ✅ 简化了代码逻辑

---

## 📊 测试建议

### 测试场景1: 打包工序推送

```
输入:
- 备料计划: bl01
- 来源工序: 打包
- 需补货数量: 10

预期结果:
- ✅ 推送到packing_process_plans
- ✅ process_name = '打包'
- ✅ source_no = 'bl01'
```

### 测试场景2: 组装工序推送

```
输入:
- 备料计划: bl02
- 来源工序: 组装
- 需补货数量: 5

预期结果:
- ✅ 推送到assembly_process_plans
- ✅ process_name = '组装'
- ✅ source_no = 'bl02'
```

### 测试场景3: 采购工序不推送

```
输入:
- 备料计划: bl04
- 来源工序: 采购
- 需补货数量: 20

预期结果:
- ❌ 不推送
- 日志: "来源工序=采购，不在推送范围内"
```

---

## 🎉 修复完成

**修复状态**: ✅ 完成  
**测试状态**: ⏳ 待验证  
**文档更新**: ✅ 完成

**下一步**:
1. 清理历史脏数据（SO2025000002）
2. 执行完整的递归数据流测试
3. 验证日志输出是否符合预期

---

**修复人**: AI Assistant  
**审核人**: 待定  
**报告时间**: 2025-12-15 09:50
