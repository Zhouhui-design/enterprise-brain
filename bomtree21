const logger = require('../utils/logger');

class TreeService {
  /**
   * 将扁平列表转换为树形结构
   */
  async generateBomTree(nodes) {
    if (!nodes || nodes.length === 0) return [];
    
    // 创建节点映射
    const nodeMap = new Map();
    const rootNodes = [];
    
    // 第一遍：创建节点映射
    nodes.forEach(node => {
      const nodeData = node.toJSON ? node.toJSON() : node;
      nodeData.children = [];
      nodeMap.set(nodeData.id, nodeData);
    });
    
    // 第二遍：构建树
    nodes.forEach(node => {
      const nodeData = nodeMap.get(node.id);
      
      if (nodeData.parent_node_id && nodeMap.has(nodeData.parent_node_id)) {
        // 添加到父节点的children中
        const parentNode = nodeMap.get(nodeData.parent_node_id);
        if (parentNode) {
          parentNode.children.push(nodeData);
          parentNode.children.sort((a, b) => a.sort_order - b.sort_order);
        }
      } else {
        // 根节点
        rootNodes.push(nodeData);
      }
    });
    
    // 按层级和排序号排序根节点
    rootNodes.sort((a, b) => {
      if (a.level !== b.level) return a.level - b.level;
      return a.sort_order - b.sort_order;
    });
    
    return rootNodes;
  }
  
  /**
   * 计算BOM成本
   */
  async calculateBomCost(bomInstanceId) {
    try {
      // 获取BOM所有节点
      const nodes = await BomNode.findAll({
        where: { bom_instance_id: bomInstanceId },
        include: [Product]
      });
      
      // 转换为树形结构
      const tree = await this.generateBomTree(nodes);
      
      // 递归计算成本
      const calculateNodeCost = (node) => {
        if (!node) return 0;
        
        // 如果节点有单位成本，直接使用
        if (node.unit_cost) {
          node.total_cost = node.unit_cost * node.quantity;
          return node.total_cost;
        }
        
        // 如果是叶节点但没有成本，尝试从产品获取标准成本
        if (node.is_leaf && node.Product && node.Product.standard_cost) {
          node.unit_cost = node.Product.standard_cost;
          node.total_cost = node.unit_cost * node.quantity;
          return node.total_cost;
        }
        
        // 计算子节点成本总和
        if (node.children && node.children.length > 0) {
          let childrenTotalCost = 0;
          node.children.forEach(child => {
            childrenTotalCost += calculateNodeCost(child);
          });
          
          // 考虑损耗率
          const scrapMultiplier = 1 + (node.scrap_rate || 0) / 100;
          node.total_cost = childrenTotalCost * scrapMultiplier;
          node.unit_cost = node.total_cost / node.quantity;
          
          return node.total_cost;
        }
        
        return 0;
      };
      
      // 从根节点开始计算
      let totalCost = 0;
      tree.forEach(rootNode => {
        totalCost += calculateNodeCost(rootNode);
      });
      
      return {
        total_cost: totalCost,
        nodes: tree
      };
    } catch (error) {
      logger.error('计算BOM成本失败:', error);
      throw error;
    }
  }
  
  /**
   * 生成BOM层级统计
   */
  async generateBomStatistics(bomInstanceId) {
    try {
      const stats = {
        total_nodes: 0,
        levels: {},
        product_types: {},
        cost_summary: {
          total: 0,
          by_level: {}
        },
        lead_time_summary: {
          max: 0,
          critical_path: []
        }
      };
      
      const nodes = await BomNode.findAll({
        where: { bom_instance_id: bomInstanceId },
        include: [Product, Process]
      });
      
      // 统计信息
      nodes.forEach(node => {
        stats.total_nodes++;
        
        // 层级统计
        if (!stats.levels[node.level]) {
          stats.levels[node.level] = 0;
        }
        stats.levels[node.level]++;
        
        // 产品类型统计
        if (node.Product && node.Product.product_type) {
          if (!stats.product_types[node.Product.product_type]) {
            stats.product_types[node.Product.product_type] = 0;
          }
          stats.product_types[node.Product.product_type]++;
        }
        
        // 成本统计
        if (node.total_cost) {
          stats.cost_summary.total += parseFloat(node.total_cost);
          
          if (!stats.cost_summary.by_level[node.level]) {
            stats.cost_summary.by_level[node.level] = 0;
          }
          stats.cost_summary.by_level[node.level] += parseFloat(node.total_cost);
        }
        
        // 提前期统计
        if (node.lead_time && node.lead_time > stats.lead_time_summary.max) {
          stats.lead_time_summary.max = node.lead_time;
        }
      });
      
      return stats;
    } catch (error) {
      logger.error('生成BOM统计信息失败:', error);
      throw error;
    }
  }
  
  /**
   * 查找BOM中的特定产品
   */
  async findProductInBom(bomInstanceId, productCode) {
    try {
      const nodes = await BomNode.findAll({
        where: { bom_instance_id: bomInstanceId },
        include: [{
          model: Product,
          where: { product_code: productCode }
        }]
      });
      
      return nodes;
    } catch (error) {
      logger.error('查找BOM中的产品失败:', error);
      throw error;
    }
  }
  
  /**
   * 获取BOM的完整路径（从根节点到指定节点）
   */
  async getBomNodePath(bomInstanceId, nodeId) {
    try {
      const path = [];
      let currentNode = await BomNode.findByPk(nodeId, {
        include: [Product]
      });
      
      if (!currentNode) {
        return null;
      }
      
      // 添加当前节点
      path.unshift(currentNode);
      
      // 向上追溯父节点
      while (currentNode.parent_node_id) {
        currentNode = await BomNode.findByPk(currentNode.parent_node_id, {
          include: [Product]
        });
        if (currentNode) {
          path.unshift(currentNode);
        } else {
          break;
        }
      }
      
      return path;
    } catch (error) {
      logger.error('获取BOM节点路径失败:', error);
      throw error;
    }
  }
}

module.exports = new TreeService();