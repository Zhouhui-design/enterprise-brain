# ✅ 打包工序定时工额问题分析与修复报告

**日期**: 2025-12-19  
**问题**: 打包工序前端显示定时工额=0.00，数据库中=6.00

---

## 📊 问题分析

### 1. 数据库字段结构
经过完整检查，发现两个独立的字段系统：

| 数据库表 | 字段名 | 用途 | 实际值 |
|---------|-------|------|--------|
| `materials`（产品物料库） | `standard_time` | 存储定时工额基准值 | 6.00 |
| `packing_process_plans` | `standard_work_quota` | 工序计划的定时工额 | **0.00**（错误） |

### 2. 数据流追踪

```
┌─────────────────┐
│ materials表     │  standard_time = 6.00
│ material_code   │
│  = 6001A0306    │
└────────┬────────┘
         │
         │  ✅ Lookup规则：
         │  SELECT standard_time 
         │  FROM materials 
         │  WHERE material_code = ?
         │
         ▼
┌─────────────────────┐
│ 后端Service        │  standardWorkQuota = 6.00
│ packingProcess     │
│ PlanService.js     │
└────────┬────────────┘
         │
         │  ⚠️ 问题点：
         │  数据库插入时值正确
         │  但前端编辑时未正确加载
         │
         ▼
┌──────────────────────┐
│ packing_process      │  standard_work_quota = 0.00
│ _plans表             │  ❌ 错误！
└──────────────────────┘
         │
         ▼
┌──────────────────────┐
│ 前端Vue组件         │  formData.standardWorkQuota = 0.00
│ Packing            │  ❌ 显示错误值
│ ProcessPlanList.vue │
└──────────────────────┘
```

---

## 🔧 根本原因

### 测试结果证明：

1. **数据库Lookup ✅ 正确**
   ```bash
   $ node verify-packing-lookup.js
   ✅ 查询成功: standard_time = 6
   ✅ 插入成功, 新ID: 13
   ✅ 验证通过！定时工额 = 6.00
   ```

2. **后端Service ✅ 正确**
   - 包含lookup逻辑（第210-230行）
   - 正确查询materials表
   - 正确映射字段

3. **前端问题 ❌**
   - 旧记录（id=12）的 `standard_work_quota = 0.00` 是历史遗留数据
   - **真正问题**：前端`handleEdit`函数可能存在字段映射问题

---

## 🛠️ 已完成的修复

### 1. 后端修复（所有16个工序计划服务）

**文件**: `backend/services/packingProcessPlanService.js`（及其他15个）

```javascript
// ✅ 添加定时工额Lookup逻辑
static async create(data) {
  try {
    let standardWorkQuota = data.standardWorkQuota || 0;
    
    // 规则：lookup(产品物料库的"物料编号"=当前工序计划的"生产产品编号"，
    //      产品物料库的"定时工额")
    if (data.productCode) {
      try {
        console.log(`🔍 [定时工额Lookup] 查询产品物料库: 物料编号=${data.productCode}`);
        const [materialRows] = await pool.execute(
          'SELECT standard_time FROM materials WHERE material_code = ?',
          [data.productCode]
        );
        
        if (materialRows.length > 0 && materialRows[0].standard_time) {
          standardWorkQuota = parseFloat(materialRows[0].standard_time);
          console.log(`✅ [定时工额Lookup] 找到定时工额: ${standardWorkQuota}`);
        } else {
          console.log(`⚠️ [定时工额Lookup] 未找到物料编号=${data.productCode}的定时工额，使用默认值: ${standardWorkQuota}`);
        }
      } catch (lookupError) {
        console.error(`❌ [定时工额Lookup] 查询失败:`, lookupError);
      }
    }
    
    // ... 插入数据库时使用standardWorkQuota
  }
}
```

### 2. 前端修复

**文件**: `07-frontend/src/pages/production-planning/PackingProcessPlanList.vue`

#### 修复1: 添加productCode监听器
```javascript
// ✅ 监听生产产品编号变化，自动lookup定时工额
watch(
  () => formData.value.productCode,
  async (newProductCode) => {
    if (!newProductCode) return;
    
    try {
      console.log(`🔍 [定时工额Lookup] 查询产品物料库: 物料编号=${newProductCode}`);
      const response = await materialApiService.getMaterialByCode(newProductCode);
      
      if (response?.data?.standardTime) {
        formData.value.standardWorkQuota = parseFloat(response.data.standardTime);
        console.log(`✅ [定时工额Lookup] 找到定时工额: ${formData.value.standardWorkQuota}`);
      }
    } catch (error) {
      console.error('查询定时工额失败:', error);
    }
  }
)
```

#### 修复2: handleEdit字段映射兼容
```javascript
const handleEdit = (row) => {
  console.log('🔍 编辑行原始数据:', row);
  
  formData.value = {
    ...row,
    // ✅ 兼容两种字段命名格式
    standardWorkQuota: row.standardWorkQuota || row.standard_work_quota || 0,
    productCode: row.productCode || row.product_code || '',
    // ... 其他字段
  };
  
  console.log('📝 表单数据:', formData.value);
};
```

### 3. 语法错误修复

**文件**: `07-frontend/src/pages/production-planning/SprayPaintingProcessPlanList.vue`

**问题**: 第537行有孤立的 `wa`（`watch`被截断）

**修复**: 
```diff
- // 监听需补货数量和定时工额变化，自动计算需求工时
- wa
-
// ✅ 监听生产产品编号变化，自动lookup定时工额
```

---

## ✅ 验证清单

### 数据库层面
- [x] materials表包含standard_time字段（值=6.00）
- [x] packing_process_plans表包含standard_work_quota字段
- [x] Lookup查询SQL正确
- [x] 手动创建测试记录验证通过（新记录standard_work_quota=6.00）

### 后端层面
- [x] packingProcessPlanService.js包含lookup逻辑
- [x] 所有16个工序计划服务已添加lookup逻辑
- [x] 后端服务成功启动（无语法错误）

### 前端层面
- [x] 添加productCode监听器
- [x] handleEdit函数支持字段名兼容（snake_case/camelCase）
- [x] 喷塑工序页面语法错误已修复

---

## 🎯 下一步验证步骤

### 1. 测试新建打包工序计划
1. 访问 `http://localhost:3003/production-planning/packing-process-plan`
2. 点击"新建"
3. 选择产品编号 `6001A0306`
4. **预期**：定时工额自动填充为 `6.00`

### 2. 测试编辑现有记录
1. 编辑id=13的记录（刚才测试创建的）
2. **预期**：定时工额显示为 `6.00`
3. 修改产品编号为其他物料
4. **预期**：定时工额自动更新为对应值

### 3. 检查浏览器控制台
监听以下日志：
```
🔍 [定时工额Lookup] 查询产品物料库: 物料编号=6001A0306
✅ [定时工额Lookup] 找到定时工额: 6
```

---

## 📝 技术要点总结

1. **字段命名映射**
   - 数据库: `snake_case` (standard_work_quota)
   - 前端: `camelCase` (standardWorkQuota)
   - **解决方案**: 后端统一转换，前端兼容读取

2. **Lookup规则实现位置**
   - ✅ 后端Service: `create()` 和 `update()` 方法
   - ✅ 前端Vue: `watch` 监听器

3. **数据源区分**
   - **基准数据**: `materials.standard_time`（不可修改）
   - **计划数据**: `*_process_plans.standard_work_quota`（lookup填充）

---

## 🔄 遗留问题（需前端验证）

1. **旧数据兼容性**
   - 历史记录（id<13）的定时工额=0.00
   - **建议**: 提供"批量修复"功能，重新lookup所有记录

2. **前端API调用**
   - 需验证 `materialApiService.getMaterialByCode()` 是否返回正确格式
   - 需确认响应字段是 `standardTime` 还是 `standard_time`

3. **强制刷新机制**
   - 用户已有数据可能被浏览器缓存
   - **建议**: 清除LocalStorage或强制Ctrl+F5刷新

---

## 🎉 结论

**根本原因**: 历史数据创建时未执行lookup，导致数据库中值为0.00

**修复状态**: 
- ✅ 后端lookup逻辑已添加并验证通过
- ✅ 前端监听器已添加
- ✅ 语法错误已修复
- ⏳ 需前端实际操作验证

**下一步**: 
1. 强刷前端页面（Ctrl+Shift+R）
2. 测试新建和编辑功能
3. 查看浏览器控制台日志
4. 如有问题，提供具体的控制台错误信息
