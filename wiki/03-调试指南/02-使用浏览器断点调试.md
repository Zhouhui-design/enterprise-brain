# 使用浏览器断点调试

## 🎯 什么是断点调试

断点调试是前端开发中最强大的调试工具，可以让您：
- 暂停代码执行
- 查看变量的实时值
- 单步执行代码
- 追踪函数调用链
- 修改变量值进行测试

## 📚 基础操作

### 1. 打开开发者工具

**Windows/Linux**：
- 按 `F12`
- 或 `Ctrl + Shift + I`
- 或右键点击页面 → 检查

**Mac**：
- 按 `Cmd + Option + I`
- 或右键点击页面 → 检查元素

### 2. 切换到Sources面板

![Sources面板](https://via.placeholder.com/800x400?text=Sources+Panel)

1. 点击顶部的"Sources"标签
2. 左侧是文件树
3. 中间是代码编辑器
4. 右侧是调试面板

### 3. 找到要调试的文件

**方法1：通过文件树**
```
webpack://
  └─ src/
     └─ pages/
        └─ production-planning/
           └─ RealProcessPlanList.vue
```

**方法2：使用搜索（推荐）**
- 按 `Ctrl + P`（Windows/Linux）或 `Cmd + P`（Mac）
- 输入文件名：`RealProcessPlanList.vue`
- 按回车打开文件

### 4. 设置断点

#### 方法1：点击行号
- 在代码行号左侧点击
- 会出现一个蓝色圆点
- 再次点击可取消断点

#### 方法2：条件断点
- 右键点击行号
- 选择"Add conditional breakpoint"
- 输入条件，如：`requiredWorkHours > 10`
- 只有条件满足时才会暂停

#### 方法3：代码中插入
```javascript
debugger;  // 执行到这里会自动暂停
```

## 🔧 实战案例：调试真工序计划

### 场景：计划开始日期未生成

#### 第一步：设置关键断点

打开 `RealProcessPlanList.vue`，在以下位置设置断点：

1. **queryPlanStartDate 函数入口**（第486行）
```javascript
const queryPlanStartDate = async () => {  // ← 在这里设置断点
  const requiredWorkHours = parseFloat(formData.value.requiredWorkHours) || 0
  // ...
}
```

2. **API调用前**（第509行）
```javascript
const response = await capacityLoadApi.queryPlanStartDate(  // ← 在这里设置断点
  processName,
  formatDateYMD(planEndDate),
  requiredWorkHours,
  minRemainingHours
)
```

3. **响应处理**（第516行）
```javascript
if (response?.planStartDate) {  // ← 在这里设置断点
  formData.value.planStartDate = response.planStartDate
  // ...
}
```

#### 第二步：触发断点

在页面中进行以下操作：
1. 点击"新增"或"编辑"按钮
2. 修改"需补货数量"或"定时工额"
3. 代码会在第一个断点处暂停

#### 第三步：检查变量

**在断点处查看局部变量**：

右侧"Scope"面板会显示：
```
Local
  ├─ requiredWorkHours: 10.5
  ├─ processName: "焊接"
  ├─ planEndDate: "2026-01-06"
  └─ minRemainingHours: 0.5
```

**在Console中直接查询**：
```javascript
// 在断点暂停时，在Console中输入：
console.log(requiredWorkHours)  // 10.5
console.log(processName)        // "焊接"
console.log(formatDateYMD(planEndDate))  // "2026-01-06"
```

#### 第四步：单步执行

使用右侧调试按钮：

- **继续执行**（F8）：继续运行直到下一个断点
- **单步跳过**（F10）：执行当前行，不进入函数内部
- **单步进入**（F11）：执行当前行，如果是函数则进入内部
- **单步退出**（Shift+F11）：跳出当前函数
- **单步执行**：按行执行代码

**推荐流程**：
1. 第一个断点暂停后，按 `F10` 单步执行
2. 观察每个变量的赋值
3. 执行到API调用时，按 `F11` 进入函数内部
4. 查看响应对象的值

#### 第五步：查看调用栈

右侧"Call Stack"面板显示：
```
queryPlanStartDate (RealProcessPlanList.vue:486)
queryPlanEndDate (RealProcessPlanList.vue:468)
(anonymous) (RealProcessPlanList.vue:541)
```

这说明调用链是：
1. watch监听器触发
2. 调用 queryPlanEndDate()
3. 内部调用 queryPlanStartDate()

#### 第六步：修改变量测试

在断点暂停时，可以在Console中修改变量：
```javascript
// 修改需求工时进行测试
requiredWorkHours = 20
```

然后继续执行，查看不同值的影响。

## 🎓 进阶技巧

### 1. 监视表达式（Watch）

在右侧"Watch"面板添加表达式：
```javascript
formData.value.requiredWorkHours
formData.value.planEndDate
formatDateYMD(formData.value.completionDate)
```

每次代码暂停时，会实时显示这些表达式的值。

### 2. 异步代码调试

遇到 `await` 时：
```javascript
const response = await capacityLoadApi.queryPlanStartDate(...)  // ← 断点
// 按F10会等待Promise完成
// 然后在下一行暂停，此时response已有值
```

### 3. 网络请求调试

切换到"Network"面板：
1. 触发API调用
2. 找到对应的请求（如 `query-plan-start-date`）
3. 查看请求参数（Request Payload）
4. 查看响应数据（Response）
5. 查看响应时间（Timing）

**示例**：
```
Request URL: http://localhost:3005/capacity-load/query-plan-start-date
Request Method: POST
Status Code: 200 OK

Request Payload:
{
  "processName": "焊接",
  "planEndDate": "2026-01-06",
  "requiredWorkHours": 10.5,
  "minRemainingHours": 0.5
}

Response:
{
  "code": 200,
  "data": {
    "planStartDate": "2025-12-31",
    "accumulatedHours": 12.5
  },
  "message": "查询成功"
}
```

### 4. 使用logpoints（日志点）

不想暂停代码，只想输出日志？
1. 右键点击行号
2. 选择"Add logpoint"
3. 输入要输出的内容：`requiredWorkHours =`, requiredWorkHours
4. 代码执行时会自动输出到Console，但不暂停

### 5. 黑盒脚本（Blackbox Script）

有些第三方库的代码不想进入调试：
1. 在Call Stack中右键点击框架代码
2. 选择"Blackbox script"
3. 单步调试时会自动跳过这些代码

## 📋 常见调试场景

### 场景1：检查API响应格式

**问题**：response.planStartDate 为 undefined

**调试步骤**：
1. 在API调用后设置断点
2. 查看 `response` 对象的完整结构
3. 确认字段路径是否正确

```javascript
const response = await capacityLoadApi.queryPlanStartDate(...)
debugger;  // ← 在这里暂停
console.log(response)
// 预期: {code: 200, data: {planStartDate: "2025-12-31"}, message: "..."}
// 实际: {planStartDate: "2025-12-31", accumulatedHours: 12.5}
// 问题: 字段在根级别，不在data里
```

**修复**：
```javascript
// 错误写法
if (response?.data?.planStartDate) { ... }

// 正确写法
if (response?.planStartDate) { ... }
```

### 场景2：检查日期格式化

**问题**：日期显示不正确

**调试步骤**：
1. 在 `formatDateYMD` 函数内设置断点
2. 查看输入的 `date` 参数类型和值
3. 单步执行，观察转换过程

```javascript
const formatDateYMD = (date) => {
  debugger;  // ← 暂停，查看date的值
  if (!date) return ''
  if (typeof date === 'string') return date
  const d = new Date(date)
  // 继续单步，查看d的值
  const year = d.getFullYear()
  // ...
}
```

### 场景3：追踪数据流

**问题**：不知道某个值是从哪里来的

**调试步骤**：
1. 右键点击变量名
2. 选择"Find all references"
3. 查看所有使用该变量的位置
4. 在赋值语句处设置断点
5. 追踪数据流向

## 🐛 调试实战练习

### 练习1：验证计算逻辑

**任务**：验证计划开始日期的累加计算是否正确

**步骤**：
1. 打开后端路由文件 `backend/routes/capacityLoad.js`
2. 找到计划开始日期查询接口（第215行）
3. 在累加循环中设置断点（第308行）
4. 触发API调用
5. 观察累加过程

**断点位置**：
```javascript
for (let i = 0; i < rows.length; i++) {
  const row = rows[i];
  const dateStr = row.date.toISOString().split('T')[0];
  const hours = parseFloat(row.remaining_hours) || 0;
  
  accumulatedHours += hours;  // ← 在这里设置断点
  
  console.log(`  日期: ${dateStr}, 剩余工时: ${hours}, 累计: ${accumulatedHours.toFixed(2)}`);
  
  if (accumulatedHours >= required) {  // ← 再设置一个断点
    planStartDate = dateStr;
    break;
  }
}
```

**验证**：
- 第一次循环：accumulatedHours = 8.0
- 第二次循环：accumulatedHours = 15.5 (>= 10.5，应该停止)
- planStartDate 应该是第二次循环的日期

### 练习2：检查前后端数据一致性

**任务**：确认前端传递的参数和后端接收的参数一致

**步骤**：
1. 前端设置断点（API调用前）
2. 后端设置断点（接收参数处）
3. 对比参数值
4. 检查数据类型

**前端断点**：
```javascript
const response = await capacityLoadApi.queryPlanStartDate(
  processName,           // 检查这个值
  formatDateYMD(planEndDate),  // 检查格式化后的值
  requiredWorkHours,     // 检查这个值
  minRemainingHours      // 检查这个值
)
```

**后端断点**：
```javascript
const { processName, planEndDate, requiredWorkHours, minRemainingHours } = req.body;
debugger;  // 检查接收到的值
```

## 📖 快速参考卡

| 操作 | 快捷键（Windows） | 快捷键（Mac） |
|------|------------------|--------------|
| 打开开发者工具 | F12 | Cmd+Option+I |
| 搜索文件 | Ctrl+P | Cmd+P |
| 继续执行 | F8 | F8 |
| 单步跳过 | F10 | F10 |
| 单步进入 | F11 | F11 |
| 单步退出 | Shift+F11 | Shift+F11 |
| 搜索代码 | Ctrl+F | Cmd+F |
| 全局搜索 | Ctrl+Shift+F | Cmd+Shift+F |

## 💡 最佳实践

1. **先看Console，再设断点**：Console输出可能已经告诉你问题所在
2. **从外向内调试**：先在最外层设断点，逐步深入
3. **善用条件断点**：避免在循环中频繁暂停
4. **记录调试过程**：发现问题时记录下来，更新Wiki
5. **清除不用的断点**：避免意外暂停
6. **使用logpoints代替console.log**：不用修改代码

## 🎯 调试检查清单

调试前确认：
- [ ] 已打开开发者工具
- [ ] 已切换到Sources面板
- [ ] 已找到正确的文件
- [ ] 已设置断点
- [ ] 已禁用广告拦截器（可能影响断点）
- [ ] 浏览器缓存已清除（Ctrl+Shift+Delete）

---

**最后更新**：2025-12-11  
**维护者**：开发团队  
**相关文档**：
- [真工序计划调试指南](./01-真工序计划调试指南.md)
- [Quest任务管理指南](./03-Quest任务管理指南.md)
