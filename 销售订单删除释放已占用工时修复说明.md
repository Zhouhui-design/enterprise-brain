# 销售订单删除时释放已占用工时修复说明

## 问题描述

**问题**: 在销售订单页面删除订单时,虽然级联删除了关联的工序计划,但工序能力负荷表中的"已占用工时"没有被正确释放,导致数据不一致。

**影响**: 
- 工序能力负荷表的"已占用工时"累积错误,无法反映真实产能占用
- "剩余工时"计算错误,影响后续排程
- 需要手动点击"重置占用工时"才能修复

---

## 问题根源

在 `/backend/routes/salesOrders.js` 文件中:

### 单条删除 (第620-626行)
```javascript
// ❌ 旧代码: 直接删除工序计划,没有释放已占用工时
const [processPlanResult] = await connection.execute(
  'DELETE FROM process_plans WHERE sales_order_no = ?',
  [internalOrderNo]
);
```

### 批量删除 (第698-703行)
```javascript
// ❌ 旧代码: 直接删除工序计划,没有释放已占用工时
const [processPlanResult] = await connection.execute(
  'DELETE FROM process_plans WHERE sales_order_no = ?',
  [internalOrderNo]
);
totalProcessPlans += processPlanResult.affectedRows;
```

**问题**: 直接使用SQL `DELETE`语句删除工序计划,跳过了释放已占用工时的逻辑。

---

## 修复方案

### 修复逻辑

**核心思路**: 在删除工序计划前,先查询每条工序计划的详细信息,然后使用**减法逻辑**释放已占用工时,最后再删除。

**数据流**:
```
1. 查询要删除的工序计划列表 (包含: 工序名称, 计划排程日期, 计划排程工时)
   ↓
2. 遍历每条工序计划
   ↓
3. 查询工序能力负荷表对应记录
   ↓
4. 使用减法释放已占用工时: 新已占用工时 = 当前已占用工时 - 被删除的计划排程工时
   ↓
5. 重新计算剩余工时和剩余时段
   ↓
6. 更新工序能力负荷表
   ↓
7. 所有已占用工时释放完成后,执行删除工序计划
```

### 修复代码

#### 单条删除修复 (第620-697行)

```javascript
// ✅ 级联删除工序计划（销售订单编号 = 内部销售订单编号）
// ⚠️ 重要: 先查询工序计划详情,然后释放已占用工时,最后删除
const [processPlanRows] = await connection.execute(
  'SELECT plan_no, process_name, schedule_date, scheduled_work_hours FROM process_plans WHERE sales_order_no = ?',
  [internalOrderNo]
);

console.log(`🔍 查询到${processPlanRows.length}条工序计划需要删除`);

// ✅ 逾个释放已占用工时
for (const plan of processPlanRows) {
  const scheduledWorkHours = parseFloat(plan.scheduled_work_hours || 0);
  
  if (scheduledWorkHours > 0 && plan.process_name && plan.schedule_date) {
    try {
      // 格式化日期为YYYY-MM-DD
      const scheduleDate = plan.schedule_date instanceof Date 
        ? plan.schedule_date.toISOString().split('T')[0] 
        : plan.schedule_date;
      
      console.log(`🔄 [计划=${plan.plan_no}] 释放已占用工时: 工序=${plan.process_name}, 日期=${scheduleDate}, 工时=${scheduledWorkHours}`);
      
      // ✅ 使用减法逻辑释放已占用工时
      const [capacityRows] = await connection.execute(
        'SELECT id, occupied_hours, work_shift, available_workstations FROM process_capacity_load WHERE process_name = ? AND date = ?',
        [plan.process_name, scheduleDate]
      );
      
      if (capacityRows.length > 0) {
        const record = capacityRows[0];
        const currentOccupiedHours = parseFloat(record.occupied_hours || 0);
        const workShift = parseFloat(record.work_shift || 0);
        const availableWorkstations = parseFloat(record.available_workstations || 0);
        
        // ✅ 减法: 已占用工时 - 被删除的计划排程工时
        const newOccupiedHours = parseFloat(Math.max(0, currentOccupiedHours - scheduledWorkHours).toFixed(2));
        
        // 重新计算剩余工时和剩余时段
        const newRemainingHours = parseFloat(
          (workShift * availableWorkstations - newOccupiedHours).toFixed(2)
        );
        
        let newRemainingShift = null;
        if (availableWorkstations > 0) {
          newRemainingShift = parseFloat(
            (newRemainingHours / availableWorkstations).toFixed(2)
          );
        }
        
        // 更新数据库
        await connection.execute(
          `UPDATE process_capacity_load 
           SET occupied_hours = ?, 
               remaining_hours = ?, 
               remaining_shift = ?,
               updated_at = NOW()
           WHERE id = ?`,
          [newOccupiedHours, newRemainingHours, newRemainingShift, record.id]
        );
        
        console.log(`✅ [计划=${plan.plan_no}] 已占用工时释放成功: ${currentOccupiedHours} - ${scheduledWorkHours} = ${newOccupiedHours}`);
      } else {
        console.warn(`⚠️ [计划=${plan.plan_no}] 未找到工序能力负荷记录: 工序=${plan.process_name}, 日期=${scheduleDate}`);
      }
    } catch (error) {
      console.error(`❗ [计划=${plan.plan_no}] 释放已占用工时失败:`, error.message);
      // 继续处理其他记录,不阻塞删除流程
    }
  }
}

// ✅ 所有已占用工时释放完成后,执行删除
const [processPlanResult] = await connection.execute(
  'DELETE FROM process_plans WHERE sales_order_no = ?',
  [internalOrderNo]
);

console.log(`✅ 级联删除工序计划: ${processPlanResult.affectedRows} 条`);
```

#### 批量删除修复 (第698-765行)

在批量删除的循环中增加相同的释放逻辑(代码结构相同,略)。

---

## 关键技术点

### 1. 减法逻辑
```javascript
// 新已占用工时 = MAX(0, 当前已占用工时 - 被删除的计划排程工时)
const newOccupiedHours = Math.max(0, currentOccupiedHours - scheduledWorkHours);
```

- 使用`Math.max(0, ...)`确保已占用工时不会变成负数
- 保留2位小数: `.toFixed(2)`

### 2. 联动计算
释放已占用工时后,自动重新计算:
- **剩余工时** = (上班时段 × 可用工位数量) - 新已占用工时
- **剩余时段** = 剩余工时 ÷ 可用工位数量

### 3. 日期格式化
```javascript
const scheduleDate = plan.schedule_date instanceof Date 
  ? plan.schedule_date.toISOString().split('T')[0] 
  : plan.schedule_date;
```
确保日期格式统一为`YYYY-MM-DD`,避免匹配失败。

### 4. 异常处理
```javascript
try {
  // 释放已占用工时
} catch (error) {
  console.error(`❗ 释放已占用工时失败:`, error.message);
  // 继续处理其他记录,不阻塞删除流程
}
```
单条释放失败不影响其他记录,也不阻塞删除流程。

---

## 验证步骤

### 验证前准备:
1. 打开浏览器控制台(F12)
2. 打开后端日志: `tail -f /home/sardenesy/ai_workspaces/ai_desktop_3/backend.log`

### 验证步骤:

#### 步骤1: 查看初始状态
1. 打开工序能力负荷表页面: http://localhost:3003/mrp/capacity-load
2. 记录某个工序某天的"已占用工时"值(例如: 工序A, 2025-12-16, 已占用工时=10.50)

#### 步骤2: 创建销售订单并下单
1. 打开销售订单页面: http://localhost:3003/sales/sales-order/list-new
2. 创建一个新订单,正式下单,生成工序计划
3. 刷新工序能力负荷表,查看"已占用工时"是否增加

#### 步骤3: 删除销售订单
1. 在销售订单页面,选中刚创建的订单
2. 点击"删除"按钮
3. 确认删除

#### 步骤4: 验证已占用工时是否释放
1. 刷新工序能力负荷表页面
2. 检查"已占用工时"是否恢复到删除前的值
3. 检查"剩余工时"是否相应增加

### 预期结果:

**控制台日志**:
```
🗑️ 删除订单: { id: 123, internalOrderNo: 'SO2025...' }
✅ 级联删除主生产计划: 1 条
✅ 级联删除备料计划: 3 条
🔍 查询到3条工序计划需要删除
🔄 [计划=PP2025...] 释放已占用工时: 工序=工序A, 日期=2025-12-16, 工时=5.00
✅ [计划=PP2025...] 已占用工时释放成功: 10.50 - 5.00 = 5.50
✅ 级联删除工序计划: 3 条
✅ 订单删除成功
```

**工序能力负荷表**:
- "已占用工时"正确减少(例如: 10.50 → 5.50)
- "剩余工时"正确增加
- "剩余时段"正确更新

---

## 影响范围

**修改文件**:
- `/backend/routes/salesOrders.js` (单条删除 + 批量删除)

**影响接口**:
- `DELETE /api/sales-orders/:id` (单条删除)
- `POST /api/sales-orders/batch-delete` (批量删除)

**数据表**:
- `sales_orders` (销售订单)
- `process_plans` (工序计划)
- `process_capacity_load` (工序能力负荷表)

**级联删除链**:
```
销售订单删除
  ↓
主生产计划删除
  ↓
备料计划删除
  ↓
工序计划删除 ← ✅ 新增: 释放已占用工时
  ↓
工序能力负荷表更新 (已占用工时, 剩余工时, 剩余时段)
```

---

## 性能优化

- 使用数据库事务保证数据一致性
- 批量查询减少数据库往返次数
- 异常不阻塞删除流程,保证删除可靠性
- 详细日志方便调试和监控

---

## 后续优化建议

1. **性能优化**: 如果删除的工序计划很多,可以考虑批量更新工序能力负荷表
2. **日志归档**: 可以将释放已占用工时的操作记录到日志表,方便审计
3. **前端提示**: 删除成功后可以显示释放的总工时数
4. **回滚机制**: 如果释放失败,可以考虑回滚删除操作

---

## 修复时间
- **修复日期**: 2025-12-11
- **修复版本**: v1.1.0
- **修复人员**: AI Assistant

