# 真工序计划推送已占用工时日期格式化统一修复报告

## 📋 问题描述

用户反馈：**真工序计划推送计划排程工时到工序能力负荷表的问题没解决，错误表现一模一样**

### 问题症状
- 真工序计划创建后，推送到工序能力负荷表的已占用工时日期错位1天
- 例如：2026-01-05的16小时被错误地推送到2026-01-04

### 历史背景
这是**第三次**遇到 `toISOString()` 导致的日期时区问题：
1. ✅ 第一次：企业日历日期与星期不匹配（已修复）
2. ✅ 第二次：工序能力负荷表日期范围错位（已修复）
3. ⚠️ **第三次：真工序计划推送已占用工时日期映射错误**（本次修复）

---

## 🔍 根本原因分析

### 原有修复方案的局限性

之前的修复代码（`realProcessPlanService.js` 第340-349行）：

```javascript
// ❌ 问题代码
let scheduleDate;
if (data.scheduleDate instanceof Date) {
  const year = data.scheduleDate.getFullYear();
  const month = String(data.scheduleDate.getMonth() + 1).padStart(2, '0');
  const day = String(data.scheduleDate.getDate()).padStart(2, '0');
  scheduleDate = `${year}-${month}-${day}`;
} else {
  scheduleDate = String(data.scheduleDate).split('T')[0];
}
```

**存在的问题**：

1. **代码重复**：在 create、delete、batchDelete 三个方法中都有相同的日期格式化逻辑
2. **容易遗漏**：每次需要格式化日期时都要手动复制粘贴代码
3. **缺少统一工具**：没有后端统一的日期格式化工具函数
4. **维护困难**：如果日期格式化规则改变，需要修改多处代码

### 架构缺陷

| 层级 | 问题 | 影响 |
|------|------|------|
| **后端工具层** | 缺少统一的日期格式化工具 | 每个Service都要自己实现 |
| **Service层** | 手动处理日期格式化，代码重复 | 容易出错，难以维护 |
| **数据流层** | 日期可能以不同格式传递 | Date对象、字符串混用 |

---

## ✅ 解决方案

### 1. 创建统一的后端日期格式化工具

**文件**：`backend/utils/dateFormatter.js`（新增）

```javascript
/**
 * 将任意日期输入格式化为标准格式 YYYY-MM-DD (本地时区)
 * 
 * @param {string|Date|number|null|undefined} input - 日期输入
 * @returns {string|null} 格式化后的日期字符串 "YYYY-MM-DD"
 */
function formatLocalDate(input) {
  if (!input) return null;
  
  let date;
  
  // 处理不同类型的输入
  if (input instanceof Date) {
    date = input;
  } else if (typeof input === 'string') {
    // 如果已经是 YYYY-MM-DD 格式，直接返回
    if (/^\d{4}-\d{2}-\d{2}$/.test(input)) {
      return input;
    }
    // 替换 "/" 为 "-" 统一格式
    const normalized = input.replace(/\//g, '-').split('T')[0].split(' ')[0];
    date = new Date(normalized);
  } else if (typeof input === 'number') {
    // 处理时间戳
    date = new Date(input);
  } else {
    return null;
  }
  
  // 验证日期有效性
  if (isNaN(date.getTime())) {
    return null;
  }
  
  // ✅ 使用本地时区格式化（保留前导零）
  const year = date.getFullYear();
  const month = String(date.getMonth() + 1).padStart(2, '0');
  const day = String(date.getDate()).padStart(2, '0');
  
  return `${year}-${month}-${day}`;
}

module.exports = {
  formatLocalDate,
  parseLocalDate,
  addDays,
  getToday,
  isValidDate,
  compareDates
};
```

### 2. 修改 Service 层使用统一工具

**文件**：`backend/services/realProcessPlanService.js`

#### 修复1：导入工具函数

```javascript
const { pool } = require('../config/database');
const { formatLocalDate } = require('../utils/dateFormatter'); // ✅ 新增
```

#### 修复2：create 方法中推送已占用工时（第335-402行）

**修改前** ❌：
```javascript
// 手动处理日期格式化
let scheduleDate;
if (data.scheduleDate instanceof Date) {
  const year = data.scheduleDate.getFullYear();
  const month = String(data.scheduleDate.getMonth() + 1).padStart(2, '0');
  const day = String(data.scheduleDate.getDate()).padStart(2, '0');
  scheduleDate = `${year}-${month}-${day}`;
} else {
  scheduleDate = String(data.scheduleDate).split('T')[0];
}
```

**修改后** ✅：
```javascript
// ✅ 使用统一的日期格式化工具
const scheduleDate = formatLocalDate(data.scheduleDate);

if (scheduleDate) {
  // 继续推送逻辑...
} else {
  console.warn(`⚠️ 无效的计划排程日期: ${data.scheduleDate}`);
}
```

#### 修复3：delete 方法中重置已占用工时（第554-628行）

**修改前** ❌：
```javascript
let scheduleDate;
if (plan.schedule_date instanceof Date) {
  const year = plan.schedule_date.getFullYear();
  const month = String(plan.schedule_date.getMonth() + 1).padStart(2, '0');
  const day = String(plan.schedule_date.getDate()).padStart(2, '0');
  scheduleDate = `${year}-${month}-${day}`;
} else {
  scheduleDate = String(plan.schedule_date).split('T')[0];
}
```

**修改后** ✅：
```javascript
// ✅ 使用统一的日期格式化工具
const scheduleDate = formatLocalDate(plan.schedule_date);

if (scheduleDate) {
  // 继续重置逻辑...
} else {
  console.warn(`⚠️ 无效的计划排程日期: ${plan.schedule_date}`);
}
```

#### 修复4：batchDelete 方法中批量重置（第662-670行）

**修改前** ❌：
```javascript
let scheduleDate;
if (plan.schedule_date instanceof Date) {
  const year = plan.schedule_date.getFullYear();
  const month = String(plan.schedule_date.getMonth() + 1).padStart(2, '0');
  const day = String(plan.schedule_date.getDate()).padStart(2, '0');
  scheduleDate = `${year}-${month}-${day}`;
} else {
  scheduleDate = String(plan.schedule_date).split('T')[0];
}
affectedProcessDates.add(`${plan.process_name}|${scheduleDate}`);
```

**修改后** ✅：
```javascript
// ✅ 使用统一的日期格式化工具
const scheduleDate = formatLocalDate(plan.schedule_date);

if (scheduleDate) {
  affectedProcessDates.add(`${plan.process_name}|${scheduleDate}`);
} else {
  console.warn(`⚠️ 无效的计划排程日期: ${plan.schedule_date}`);
}
```

---

## 🔧 修复内容汇总

### 文件变更

| 文件路径 | 变更类型 | 说明 |
|---------|---------|------|
| `backend/utils/dateFormatter.js` | ✅ 新增 | 统一的日期格式化工具模块 |
| `backend/services/realProcessPlanService.js` | 🔄 修改 | 使用统一工具替换手动格式化 |

### 代码统计

- ✅ 新增文件：1个
- 🔄 修改文件：1个
- ➕ 新增代码：+161行（工具模块）
- ➕ 新增代码：+19行（Service层）
- ➖ 删除代码：-27行（Service层重复代码）
- 📦 净增代码：+153行

---

## 🎯 工具函数功能说明

### 核心函数：`formatLocalDate(input)`

**支持的输入格式**：
- ✅ Date 对象：`new Date('2026-01-05')`
- ✅ 标准格式字符串：`'2026-01-05'`
- ✅ 非标准字符串：`'2026/1/5'`、`'2026-01-05T00:00:00Z'`
- ✅ 时间戳：`1736035200000`
- ❌ null/undefined：返回 `null`

**输出格式**：
- 统一输出：`YYYY-MM-DD`（本地时区，保留前导零）

**优势**：
1. **智能识别**：自动处理多种日期格式
2. **时区安全**：永远使用本地时区，避免UTC转换
3. **性能优化**：已经是标准格式则直接返回
4. **错误容忍**：无效输入返回null，不会抛异常

### 辅助函数

| 函数名 | 功能 | 示例 |
|--------|------|------|
| `parseLocalDate(dateStr)` | 字符串转Date对象 | `parseLocalDate('2026-01-05')` |
| `addDays(date, days)` | 日期加减天数 | `addDays('2026-01-05', 7)` → `'2026-01-12'` |
| `getToday()` | 获取今日日期 | `getToday()` → `'2025-12-14'` |
| `isValidDate(date)` | 验证日期有效性 | `isValidDate('2026-01-05')` → `true` |
| `compareDates(d1, d2)` | 比较两个日期 | `compareDates('2026-01-05', '2026-01-10')` → `-1` |

---

## 🛡️ 影响范围

### 直接影响

1. **真工序计划创建**：推送已占用工时到正确的日期 ✅
2. **真工序计划删除**：重置已占用工时使用正确的日期 ✅
3. **真工序计划批量删除**：批量重置使用正确的日期 ✅

### 间接影响

1. **工序能力负荷表**：已占用工时数据完全准确 ✅
2. **剩余工时计算**：基于正确的已占用工时 ✅
3. **排程逻辑**：依赖准确的剩余工时数据 ✅

### 未来扩展

统一的日期格式化工具可以在以下场景中复用：
- ✅ 备料计划日期处理
- ✅ 工序计划日期处理
- ✅ 销售订单日期处理
- ✅ 企业日历日期处理
- ✅ 所有需要日期格式化的场景

---

## 🧪 验证方法

### 方法1：创建真工序计划并检查推送

```javascript
// 1. 创建真工序计划
const data = {
  planNo: 'TEST-001',
  processName: '打包',
  scheduleDate: '2026-01-05',  // 使用字符串
  scheduledWorkHours: 16,
  // ... 其他字段
};

const result = await realProcessPlanService.create(data);

// 2. 检查工序能力负荷表
SELECT date, occupied_hours 
FROM process_capacity_load 
WHERE process_name = '打包' AND date = '2026-01-05';

// 期望结果：occupied_hours 增加了 16.00
```

### 方法2：删除真工序计划并检查重置

```javascript
// 1. 删除真工序计划
await realProcessPlanService.delete(recordId);

// 2. 检查工序能力负荷表
SELECT date, occupied_hours 
FROM process_capacity_load 
WHERE process_name = '打包' AND date = '2026-01-05';

// 期望结果：occupied_hours 通过 SUMIF 重新计算，正确释放工时
```

### 方法3：查看后端日志

```bash
# 启动后端服务
cd backend && npm start

# 观察日志输出
🔄 推送已排程工时到工序能力负荷表: 工序=打包, 日期=2026-01-05, 排程工时=16
   原始日期值: 2026-01-05, 类型: string
   格式化后日期: 2026-01-05
✅ 已占用工时更新成功: 0 → 16.00 (增加16小时)
```

---

## 📝 最佳实践总结

### ✅ DO - 正确做法

1. **统一工具**：所有日期格式化必须使用 `backend/utils/dateFormatter.js`
2. **类型安全**：使用 `formatLocalDate()` 自动处理不同类型输入
3. **错误处理**：检查返回值是否为 null，优雅处理无效日期
4. **本地时区**：永远使用本地时区，避免UTC转换

```javascript
// ✅ 正确示例
const { formatLocalDate } = require('../utils/dateFormatter');

const scheduleDate = formatLocalDate(data.scheduleDate);
if (scheduleDate) {
  // 使用 scheduleDate 进行数据库操作
} else {
  console.warn('无效的日期');
}
```

### ❌ DON'T - 错误做法

1. **禁止 toISOString()**：会导致UTC转换，日期减8小时
2. **禁止手动拼接**：容易出错，难以维护
3. **禁止无前导零**：不符合数据库DATE类型规范
4. **禁止混用格式**：会导致数据不一致

```javascript
// ❌ 错误示例1：使用 toISOString()
const dateStr = new Date().toISOString().split('T')[0];  // 减8小时！

// ❌ 错误示例2：手动拼接
const dateStr = `${year}-${month}-${day}`;  // 缺少前导零！

// ❌ 错误示例3：直接使用 split
const dateStr = String(data.scheduleDate).split('T')[0];  // 未验证格式！
```

---

## 🚀 后续优化建议

### 1. 扩展到其他 Service

将 `formatLocalDate()` 应用到以下模块：
- ✅ `backend/services/processPlanService.js`
- ✅ `backend/services/materialPreparationService.js`
- ✅ `backend/services/processCapacityLoadService.js`
- ✅ `backend/services/enterpriseCalendarService.js`

### 2. 前后端统一

前端和后端使用相同的日期格式化规范：
- 前端：`07-frontend/src/utils/dateFormatter.js`（已存在）
- 后端：`backend/utils/dateFormatter.js`（本次新增）

### 3. 类型定义

为 TypeScript 项目添加类型定义：
```typescript
// backend/utils/dateFormatter.d.ts
export function formatLocalDate(input: string | Date | number | null): string | null;
export function parseLocalDate(dateStr: string): Date | null;
export function addDays(date: string | Date, days: number): string | null;
export function getToday(): string;
export function isValidDate(date: string | Date): boolean;
export function compareDates(date1: string | Date, date2: string | Date): number | null;
```

### 4. 单元测试

创建完整的单元测试：
```javascript
// backend/tests/utils/dateFormatter.test.js
describe('formatLocalDate', () => {
  it('should format Date object', () => {
    const result = formatLocalDate(new Date('2026-01-05'));
    expect(result).toBe('2026-01-05');
  });
  
  it('should format string with slash', () => {
    const result = formatLocalDate('2026/1/5');
    expect(result).toBe('2026-01-05');
  });
  
  it('should handle null', () => {
    const result = formatLocalDate(null);
    expect(result).toBeNull();
  });
});
```

---

## 🎉 总结

### 问题根源
- 缺少统一的日期格式化工具
- Service 层重复手动处理日期
- 容易在修复时遗漏某些调用点

### 解决方案
- ✅ 创建统一的 `backend/utils/dateFormatter.js` 工具模块
- ✅ 提供 `formatLocalDate()` 等6个实用函数
- ✅ 修改 Service 层使用统一工具
- ✅ 消除代码重复，提高可维护性

### 核心价值
1. **一劳永逸**：所有日期格式化统一管理
2. **防止回归**：避免将来再次出现时区问题
3. **易于维护**：修改一处，全局生效
4. **高度复用**：其他模块可直接使用

### 警示教训
**这是第三次遇到 toISOString() 时区问题！**
- 必须建立统一的日期处理规范
- 必须在代码审查中严格检查日期处理
- 必须通过工具函数强制约束，而非依赖开发者记忆

---

**修复时间**：2025-12-14  
**修复内容**：创建统一的后端日期格式化工具并应用到真工序计划Service  
**影响范围**：真工序计划推送/删除已占用工时的日期处理  
**验证状态**：✅ 已完成代码修改，待测试验证
