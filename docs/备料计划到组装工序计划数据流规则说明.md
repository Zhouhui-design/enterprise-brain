# 备料计划到组装工序计划数据流规则说明

**文档时间**: 2025-12-15 07:01  
**测试产品**: 6001A0306  
**数据流模式**: 递归推送闭环

---

## 📋 数据流概述

### 完整数据链路

```
销售订单 (确认下单)
    ↓ 自动生成
主生产计划 (执行排程)
    ↓ 自动生成
备料计划 (bl01)
    ↓ 触发推送 (IFS条件判断)
工序计划 (打包/组装)
    ↓ 推送BOM子件
备料计划 (bl02, bl03, bl04...)
    ↓ 再次触发推送 (IFS条件判断)
工序计划 (组装/打包)
    ↓ 循环往复
...直到不满足推送条件为止
```

### 数据流特点

- ✅ **自动化**: 所有步骤自动触发,无需手动干预
- ✅ **递归性**: 工序计划推送备料计划后,备料计划再次触发工序计划
- ✅ **条件判断**: 基于IFS多条件组合判断推送目标
- ✅ **数据隔离**: 不同工序计划仅处理对应工序的数据
- ✅ **闭环终止**: 当不满足推送条件时自动停止

---

## 🎯 触发条件与推送规则

### IFS条件判断公式

```javascript
IFS(
  AND(
    备料计划编号 != null,
    需补货数量 > 0,
    物料来源 = "自制",
    来源工序 = "打包"
  ) → 推送到 "打包工序计划",
  
  AND(
    备料计划编号 != null,
    需补货数量 > 0,
    物料来源 = "自制",
    来源工序 = "组装"
  ) → 推送到 "组装工序计划"
)
```

### 触发条件详解

| 条件字段 | 条件值 | 说明 |
|---------|-------|------|
| **备料计划编号** | `!= null` | 代表新数据刚生成,需要推送 |
| **需补货数量** | `> 0` | 有实际补货需求 |
| **物料来源** | `= "自制"` | 自制件需要推送到工序计划 |
| **来源工序** | `= "打包"` 或 `"组装"` | 决定推送到哪个工序计划 |

### 推送目标路由

| 来源工序 | 推送目标 | 数据库表 |
|---------|---------|---------|
| `打包` | 打包工序计划 | `real_process_plans` (RealProcessPlanList.vue) |
| `组装` | 组装工序计划 | `assembly_process_plans` (AssemblyProcessPlanList.vue) |
| `喷塑` | 喷塑工序计划 | `packing_process_plans` (PackingProcessPlanList.vue) |
| `采购` | **不推送** | - |

---

## 📊 6001A0306 数据流实例

### 第1轮: 主生产计划 → 备料计划 → 打包工序计划

#### 步骤1: 主生产计划执行排程

- **输入**: 主生产计划编号 = `MCP20251215001` (假设)
- **产品**: 6001A0306
- **动作**: 点击"执行排程"

#### 步骤2: 生成备料计划 (bl01)

自动创建备料计划:

| 字段 | 值 | 说明 |
|-----|---|------|
| 备料计划编号 | `bl01` | 新生成的编号 |
| 备料物料编号 | `6001A0306` | 主产品编号 |
| 物料来源 | `自制` | ✅ 满足条件 |
| 来源工序 | `打包` | ✅ 满足条件 |
| 需补货数量 | `10` (假设) | ✅ > 0,满足条件 |
| 备料计划编号 | `bl01` | ✅ 不为空,满足条件 |

**IFS判断结果**: ✅ 全部满足 → **推送到打包工序计划**

#### 步骤3: 生成打包工序计划

自动创建打包工序计划:

| 字段 | 值 | 说明 |
|-----|---|------|
| 工序计划编号 | `RPP20251215001` (假设) | 自动生成 |
| 主计划产品编号 | `6001A0306` | 从备料计划继承 |
| 来源编号 | `bl01` | 备料计划编号 |
| 工序名称 | `打包` | - |

---

### 第2轮: 打包工序计划 → 备料计划 → 组装工序计划

#### 步骤4: 打包工序计划推送BOM子件

根据`6001A0306`的BOM结构,提取直接子件:

**BOM子件列表**:
1. `470001A` - 来源工序=组装
2. `470002A` - 来源工序=组装
3. `511442B` - 来源工序=采购

#### 步骤5: 生成备料计划 (bl02, bl03, bl04)

自动创建3条备料计划:

| 备料计划编号 | 备料物料编号 | 来源工序 | 需补货数量 | 物料来源 | 推送目标 |
|------------|------------|---------|-----------|---------|---------|
| `bl02` | `470001A` | `组装` | `5` (假设) | `自制` | ✅ 组装工序计划 |
| `bl03` | `470002A` | `组装` | `3` (假设) | `自制` | ✅ 组装工序计划 |
| `bl04` | `511442B` | `采购` | `20` (假设) | `采购` | ❌ 不推送 |

**IFS判断结果**:
- `bl02`: ✅ 满足 AND(bl02 != null, 5 > 0, 自制, 组装) → **推送到组装工序计划**
- `bl03`: ✅ 满足 AND(bl03 != null, 3 > 0, 自制, 组装) → **推送到组装工序计划**
- `bl04`: ❌ 不满足 (物料来源=采购) → **不推送**

#### 步骤6: 生成组装工序计划

自动创建2条组装工序计划:

| 字段 | 值 (bl02) | 值 (bl03) |
|-----|----------|----------|
| 工序计划编号 | `ASP20251215001` | `ASP20251215002` |
| 主计划产品编号 | `6001A0306` | `6001A0306` |
| 生产产品编号 | `470001A` | `470002A` |
| 来源编号 | `bl02` | `bl03` |
| 工序名称 | `组装` | `组装` |

---

### 第3轮: 组装工序计划 → 备料计划 → ...

#### 步骤7: 组装工序计划推送BOM子件

- `470001A`的BOM子件 → 生成新的备料计划 (bl05, bl06...)
- `470002A`的BOM子件 → 生成新的备料计划 (bl07, bl08...)

#### 步骤8: 新备料计划再次触发推送

根据IFS条件判断,继续推送到对应的工序计划...

#### 步骤N: 循环终止

当满足以下任一条件时,数据流自动停止:

- ✅ 需补货数量 = 0 或 < 0
- ✅ 物料来源 != "自制"
- ✅ BOM子件为空 (叶子节点)
- ✅ 备料计划编号为空 (未成功创建)

---

## ⚙️ 技术实现要点

### 1. 触发时机

**关键原则**: 数据生成成功后**立即**触发推送,不等待其他操作

```javascript
// ✅ 正确: 数据INSERT成功后立即触发
await connection.execute(insertSQL, params);  // 插入备料计划
const insertedId = result.insertId;
// 立即触发推送逻辑
await this.pushToProcessPlan(insertedId, data);
```

### 2. 推送条件检查

```javascript
// 检查是否满足推送条件
const shouldPush = (
  data.planNo &&  // 备料计划编号不为空
  parseFloat(data.replenishmentQuantity || 0) > 0 &&  // 需补货数量 > 0
  data.materialSource === '自制' &&  // 物料来源 = 自制
  (data.sourceProcess === '打包' || data.sourceProcess === '组装')  // 来源工序
);

if (shouldPush) {
  if (data.sourceProcess === '打包') {
    // 推送到打包工序计划 (RealProcessPlanService)
    await RealProcessPlanService.create({...});
  } else if (data.sourceProcess === '组装') {
    // 推送到组装工序计划 (AssemblyProcessPlanService)
    await AssemblyProcessPlanService.create({...});
  }
}
```

### 3. 字段映射规则

#### 备料计划 → 工序计划

| 备料计划字段 | 工序计划字段 | 说明 |
|------------|------------|------|
| `planNo` | `sourceNo` | 来源编号 |
| `materialCode` | `productCode` | 生产产品编号 |
| `materialName` | `productName` | 生产产品名称 |
| `replenishmentQuantity` | `replenishmentQty` | 需补货数量 |
| `mainPlanProductCode` | `mainPlanProductCode` | 主计划产品编号 |
| `customerOrderNo` | `customerOrderNo` | 客户订单编号 |
| `salesOrderNo` | `salesOrderNo` | 销售订单编号 |

#### 工序计划 → 备料计划

| 工序计划字段 | 备料计划字段 | 说明 |
|------------|------------|------|
| `planNo` | `sourceProcessPlanNo` | 来源工序计划编号 |
| `productCode` | `parentCode` | 父件编号 |
| `productName` | `parentName` | 父件名称 |
| `scheduleQuantity` | `parentScheduleQuantity` | 父件排程数量 |
| `mainPlanProductCode` | `mainPlanProductCode` | 主计划产品编号 |

### 4. 递归控制

**防止无限循环的机制**:

1. **需补货数量递减**: 每次推送都会消耗需补货数量
2. **BOM层级限制**: 最终会达到叶子节点(无子件)
3. **物料来源过滤**: "采购"件不推送,终止链条
4. **条件检查**: 严格的IFS条件判断

---

## 🔍 当前代码检查要点

### 需要验证的代码位置

#### 1. 备料计划Service (`materialPreparationPlanService.js`)

**检查项**:
- [ ] `create`方法中是否实现了推送逻辑
- [ ] 推送条件判断是否正确
- [ ] 是否根据`sourceProcess`字段路由到不同工序计划
- [ ] 字段映射是否完整

#### 2. 打包工序计划Service (`realProcessPlanService.js`)

**检查项**:
- [ ] `create`方法成功后是否推送BOM子件到备料计划
- [ ] BOM子件提取逻辑是否正确
- [ ] 字段映射是否完整

#### 3. 组装工序计划Service (`assemblyProcessPlanService.js`)

**检查项**:
- [ ] `create`方法成功后是否推送BOM子件到备料计划
- [ ] BOM子件提取逻辑是否正确
- [ ] 字段映射是否完整

### 常见问题排查

#### 问题1: 备料计划生成但未推送到工序计划

**原因**:
- 触发条件不满足
- 推送逻辑未执行
- 推送过程中报错

**检查方法**:
```sql
-- 查看备料计划数据
SELECT plan_no, material_code, material_source, source_process, 
       replenishment_quantity
FROM material_preparation_plans
WHERE main_plan_product_code = '6001A0306';

-- 查看工序计划数据
SELECT plan_no, product_code, source_no, process_name
FROM real_process_plans
WHERE main_plan_product_code = '6001A0306';
```

#### 问题2: 工序计划生成但未推送回备料计划

**原因**:
- BOM详情为空
- 推送逻辑未实现
- 推送过程中报错

**检查方法**:
- 查看后端日志是否有推送记录
- 检查BOM详情字段是否有数据
- 验证`pushToMaterialPlan`方法是否被调用

---

## 📝 测试验证步骤

### 步骤1: 清空测试数据

```sql
DELETE FROM material_preparation_plans WHERE main_plan_product_code = '6001A0306';
DELETE FROM real_process_plans WHERE main_plan_product_code = '6001A0306';
DELETE FROM assembly_process_plans WHERE master_plan_product_code = '6001A0306';
```

### 步骤2: 创建销售订单

- 产品: 6001A0306
- 数量: 10
- 点击"确认下单"

### 步骤3: 执行主生产计划排程

- 找到生成的主生产计划
- 点击"执行排程"

### 步骤4: 验证数据流

#### 验证点1: 备料计划 (第1轮)

```sql
SELECT plan_no, material_code, material_source, source_process, 
       replenishment_quantity
FROM material_preparation_plans
WHERE main_plan_product_code = '6001A0306'
ORDER BY created_at ASC;
```

**预期结果**: 
- 1条记录: bl01 (6001A0306, 自制, 打包)

#### 验证点2: 打包工序计划

```sql
SELECT plan_no, product_code, source_no, process_name
FROM real_process_plans
WHERE main_plan_product_code = '6001A0306';
```

**预期结果**:
- 1条记录: RPP... (6001A0306, bl01, 打包)

#### 验证点3: 备料计划 (第2轮)

```sql
SELECT plan_no, material_code, source_process, replenishment_quantity
FROM material_preparation_plans
WHERE parent_code = '6001A0306'
ORDER BY created_at ASC;
```

**预期结果**:
- 3条记录: 
  - bl02 (470001A, 组装, >0)
  - bl03 (470002A, 组装, >0)
  - bl04 (511442B, 采购, >0)

#### 验证点4: 组装工序计划

```sql
SELECT plan_no, product_code, source_no, process_name
FROM assembly_process_plans
WHERE master_plan_product_code = '6001A0306';
```

**预期结果**:
- 2条记录:
  - ASP... (470001A, bl02, 组装)
  - ASP... (470002A, bl03, 组装)

---

## ✅ 数据流规则总结

### 核心规则

1. **触发时机**: 数据INSERT成功后立即触发
2. **推送条件**: IFS(AND(编号 != null, 数量 > 0, 来源=自制, 工序=打包/组装))
3. **推送目标**: 根据`sourceProcess`字段路由
4. **字段映射**: 严格按照映射表传递
5. **递归控制**: 通过条件检查自然终止

### 数据流链路

```
主生产计划
    ↓
备料计划 (bl01: 6001A0306, 打包)
    ↓
打包工序计划 (6001A0306)
    ↓
备料计划 (bl02: 470001A, 组装 | bl03: 470002A, 组装 | bl04: 511442B, 采购)
    ↓
组装工序计划 (470001A, 470002A)
    ↓
备料计划 (bl05, bl06... 下级子件)
    ↓
...递归直到终止
```

### 关键成功因素

- ✅ **自动化**: 全流程无需人工干预
- ✅ **准确性**: IFS条件判断精确
- ✅ **完整性**: 字段映射无遗漏
- ✅ **稳定性**: 递归控制防止死循环
- ✅ **可追溯**: 来源编号链路清晰

---

**文档结束** ✨
