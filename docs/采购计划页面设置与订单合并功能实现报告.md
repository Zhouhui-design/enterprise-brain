# 采购计划页面设置与订单合并功能实现报告

## 📋 任务概述

### 用户需求
为采购计划页面（`http://localhost:3003/purchase/procurement-plan`）添加：
1. **页面设置按钮**：包含业务变量和列字段控制功能
2. **采购订单合并规则**：下拉选择器 + 一键合并按钮
3. **业务变量**：采购订单合并规则配置

### 核心功能
- **页面设置对话框**：
  - 业务变量标签页：配置采购订单合并规则
  - 列字段控制标签页：自定义表格列显示/隐藏
  
- **一键合并功能**：
  - 按"相同供应商，相同承诺回厂日期"合并采购计划
  - 生成统一的采购订单编号
  - 支持后续推送（企业微信/钉钉/微信/QQ机器人、导出Word/PDF/Excel、打印）

---

## 🎯 实现方案

### 1. 前端实现（Vue 3 + Element Plus）

#### 1.1 页面布局调整

**文件**：`07-frontend/src/pages/purchase/ProcurementPlanList.vue`

##### 新增UI元素（页面标题栏）

```vue
<!-- 采购订单合并规则下拉 -->
<el-select 
  v-model="mergeRuleValue" 
  placeholder="采购订单合并规则"
  size="small"
  style="width: 260px; margin-left: 10px"
>
  <el-option 
    label="相同供应商，相同承诺回厂日期合并" 
    value="sameSupplierSameDate" 
  />
  <el-option 
    label="其他规则（需要其他规则，请联系周辉18627407019添加）" 
    value="customRule" 
    disabled
  />
</el-select>

<!-- 一键合并按钮 -->
<el-button 
  type="success" 
  size="small" 
  @click="handleMergeOrders"
  :disabled="!hasSelection || !mergeRuleValue"
>
  <el-icon><Connection /></el-icon>
  一键合并
</el-button>

<!-- 页面设置按钮 -->
<el-button size="small" @click="pageSettingsVisible = true">
  <el-icon><Setting /></el-icon>
  页面设置
</el-button>
```

#### 1.2 页面设置对话框

**双标签页结构**：

##### 业务变量标签页
```vue
<el-tab-pane label="业务变量" name="businessVars">
  <el-form label-width="180px">
    <el-form-item label="采购订单合并规则">
      <el-select 
        v-model="businessVars.mergeRule" 
        placeholder="请选择合并规则"
      >
        <el-option 
          label="相同供应商，相同承诺回厂日期合并" 
          value="sameSupplierSameDate" 
        />
      </el-select>
      <div style="margin-top: 8px; color: #909399; font-size: 12px">
        📝 说明：设置默认的采购订单合并规则，用于一键合并功能
        • 相同供应商，相同承诺回厂日期合并：将相同供应商且承诺回厂日期相同的采购计划合并为一个采购订单
        • 如需其他合并规则，请联系周辉18627407019
      </div>
    </el-form-item>
  </el-form>
</el-tab-pane>
```

##### 列字段控制标签页
```vue
<el-tab-pane label="列字段控制" name="columnControl">
  <el-checkbox-group v-model="selectedColumns">
    <el-checkbox 
      v-for="col in defaultColumns" 
      :key="col.prop" 
      :label="col.prop"
    >
      {{ col.label }}
    </el-checkbox>
  </el-checkbox-group>
</el-tab-pane>
```

#### 1.3 响应式状态管理

```javascript
// 页面设置相关状态
const pageSettingsVisible = ref(false)
const activeSettingsTab = ref('businessVars')
const businessVars = ref({
  mergeRule: 'sameSupplierSameDate' // 默认规则
})
const selectedColumns = ref([])

// 合并规则下拉选中值
const mergeRuleValue = ref('sameSupplierSameDate')
```

#### 1.4 核心方法实现

##### 页面设置保存
```javascript
const handleSavePageSettings = () => {
  // 同步业务变量到主界面下拉框
  mergeRuleValue.value = businessVars.value.mergeRule
  
  // 保存到localStorage
  localStorage.setItem('procurementPlan_selectedColumns', JSON.stringify(selectedColumns.value))
  localStorage.setItem('procurementPlan_businessVars', JSON.stringify(businessVars.value))
  
  ElMessage.success('页面设置保存成功')
  pageSettingsVisible.value = false
}
```

##### 一键合并处理
```javascript
const handleMergeOrders = async () => {
  if (!mergeRuleValue.value) {
    ElMessage.warning('请先选择合并规则')
    return
  }
  
  if (selectedRows.value.length === 0) {
    ElMessage.warning('请先选择要合并的采购计划')
    return
  }
  
  try {
    await ElMessageBox.confirm(
      `将选中的 ${selectedRows.value.length} 条采购计划按"相同供应商，相同承诺回厂日期"合并为采购订单，是否继续？`,
      '采购订单合并确认',
      { type: 'warning' }
    )
    
    // 调用后端API
    const result = await procurementPlanApi.mergeToOrder({
      planIds: selectedRows.value.map(row => row.id),
      mergeRule: mergeRuleValue.value
    })
    
    ElMessage.success(`合并成功！生成了 ${result.orderCount || 1} 个采购订单`)
    
    // 清空选中行并刷新数据
    selectedRows.value = []
    await loadData()
    
  } catch (error) {
    if (error !== 'cancel') {
      ElMessage.error('合并失败: ' + (error.message || '未知错误'))
    }
  }
}
```

##### 初始化加载设置
```javascript
const loadPageSettings = () => {
  // 加载列字段设置
  const savedColumns = localStorage.getItem('procurementPlan_selectedColumns')
  if (savedColumns) {
    selectedColumns.value = JSON.parse(savedColumns)
  } else {
    // 默认显示所有列
    selectedColumns.value = defaultColumns.map(col => col.prop)
  }
  
  // 加载业务变量
  const savedBusinessVars = localStorage.getItem('procurementPlan_businessVars')
  if (savedBusinessVars) {
    const parsed = JSON.parse(savedBusinessVars)
    businessVars.value = { ...businessVars.value, ...parsed }
    mergeRuleValue.value = parsed.mergeRule || 'sameSupplierSameDate'
  }
}
```

---

### 2. API层实现

**文件**：`07-frontend/src/api/procurementPlan.js`

```javascript
/**
 * ✅ 新增：采购计划合并为采购订单
 * @param {Object} data - 合并数据
 * @param {Array<Number>} data.planIds - 采购计划ID数组
 * @param {String} data.mergeRule - 合并规则（sameSupplierSameDate / customRule）
 */
mergeToOrder(data) {
  return request.post('/procurement-plans/merge-to-order', data)
}
```

---

### 3. 后端实现（Node.js + Express + MySQL）

#### 3.1 路由层

**文件**：`backend/routes/procurementPlans.js`

```javascript
/**
 * ✅ 新增：采购计划合并为采购订单
 * POST /api/procurement-plans/merge-to-order
 * Body: { planIds: [1, 2, 3], mergeRule: 'sameSupplierSameDate' }
 */
router.post('/merge-to-order', async (req, res) => {
  try {
    const { planIds, mergeRule } = req.body;
    
    if (!planIds || !Array.isArray(planIds) || planIds.length === 0) {
      return res.status(400).json({
        code: 400,
        message: '请提供要合并的采购计划ID列表'
      });
    }
    
    if (!mergeRule) {
      return res.status(400).json({
        code: 400,
        message: '请选择合并规则'
      });
    }
    
    console.log(`🔗 开始合并采购计划: ${planIds.length}条, 规则: ${mergeRule}`);
    
    const result = await procurementPlanService.mergeToOrder(planIds, mergeRule);
    
    res.json({
      code: 200,
      message: `成功合并${planIds.length}条采购计划，生成${result.orderCount}个采购订单`,
      data: result
    });
  } catch (error) {
    console.error('合并采购计划失败:', error);
    res.status(500).json({
      code: 500,
      message: '合并采购计划失败: ' + error.message
    });
  }
});
```

#### 3.2 Service层核心逻辑

**文件**：`backend/services/procurementPlanService.js`

```javascript
/**
 * ✅ 新增：采购计划合并为采购订单
 * @param {Array<Number>} planIds - 采购计划ID数组
 * @param {String} mergeRule - 合并规则（sameSupplierSameDate / customRule）
 */
async mergeToOrder(planIds, mergeRule) {
  if (!planIds || planIds.length === 0) {
    throw new Error('采购计划ID列表不能为空');
  }

  // 1️⃣ 查询所有选中的采购计划
  const placeholders = planIds.map(() => '?').join(',');
  const selectSql = `SELECT * FROM procurement_plans WHERE id IN (${placeholders})`;
  const plans = await query(selectSql, planIds);

  if (plans.length === 0) {
    throw new Error('未找到有效的采购计划');
  }

  console.log(`📋 查询到 ${plans.length} 条采购计划，开始按规则分组...`);

  // 2️⃣ 根据合并规则分组
  const groups = {};
  
  if (mergeRule === 'sameSupplierSameDate') {
    // 相同供应商 + 相同承诺回厂日期合并
    plans.forEach(plan => {
      const supplierName = plan.supplier_name || 'NO_SUPPLIER';
      const promisedDate = plan.promised_arrival_date || 'NO_DATE';
      const groupKey = `${supplierName}||${promisedDate}`;
      
      if (!groups[groupKey]) {
        groups[groupKey] = [];
      }
      groups[groupKey].push(plan);
    });
  } else {
    // 其他规则（默认全部合并为一个）
    groups['all'] = plans;
  }

  console.log(`📋 分组结果: ${Object.keys(groups).length} 个组`);

  // 3️⃣ 生成采购订单编号
  const generateOrderNo = () => {
    const year = new Date().getFullYear();
    const timestamp = Date.now().toString().slice(-6);
    const random = Math.floor(Math.random() * 1000).toString().padStart(3, '0');
    return `CGDD${year}${timestamp}${random}`;
  };

  // 4️⃣ 为每个组生成采购订单编号并更新
  const orders = [];
  for (const groupKey in groups) {
    const groupPlans = groups[groupKey];
    const purchaseOrderNo = generateOrderNo();
    
    console.log(`📝 生成采购订单: ${purchaseOrderNo}, 包含 ${groupPlans.length} 条采购计划`);
    
    // 更新所有属于该组的采购计划
    const planIdsInGroup = groupPlans.map(p => p.id);
    const updatePlaceholders = planIdsInGroup.map(() => '?').join(',');
    const updateSql = `
      UPDATE procurement_plans 
      SET purchase_order_no = ?, 
          procurement_status = 'ORDERED',
          updated_at = CURRENT_TIMESTAMP 
      WHERE id IN (${updatePlaceholders})
    `;
    
    await query(updateSql, [purchaseOrderNo, ...planIdsInGroup]);
    
    orders.push({
      purchaseOrderNo,
      planCount: groupPlans.length,
      supplierName: groupPlans[0].supplier_name,
      promisedArrivalDate: groupPlans[0].promised_arrival_date,
      planIds: planIdsInGroup
    });
  }

  console.log(`✅ 合并完成！生成了 ${orders.length} 个采购订单`);

  return {
    success: true,
    orderCount: orders.length,
    orders: orders
  };
}
```

---

## 🔍 核心逻辑详解

### 合并规则：相同供应商 + 相同承诺回厂日期

**分组算法**：
```javascript
groupKey = `${supplierName}||${promisedDate}`
```

**示例场景**：

假设选中了6条采购计划：

| ID | 供应商 | 承诺回厂日期 | 物料编号 |
|----|--------|--------------|----------|
| 1  | A公司  | 2025-01-15   | M001     |
| 2  | A公司  | 2025-01-15   | M002     |
| 3  | B公司  | 2025-01-15   | M003     |
| 4  | A公司  | 2025-01-20   | M004     |
| 5  | B公司  | 2025-01-20   | M005     |
| 6  | B公司  | 2025-01-20   | M006     |

**分组结果**：
- 组1：`A公司||2025-01-15` → [ID: 1, 2] → 生成订单编号 `CGDD2025123001`
- 组2：`B公司||2025-01-15` → [ID: 3] → 生成订单编号 `CGDD2025123002`
- 组3：`A公司||2025-01-20` → [ID: 4] → 生成订单编号 `CGDD2025123003`
- 组4：`B公司||2025-01-20` → [ID: 5, 6] → 生成订单编号 `CGDD2025123004`

**生成4个采购订单**，每个订单包含相同供应商且承诺回厂日期相同的采购计划。

---

## 📊 数据库变更

### 字段更新

**表**：`procurement_plans`

- **`purchase_order_no`**：采购订单编号（合并后赋值）
- **`procurement_status`**：采购状态（合并后更新为 `ORDERED`）
- **`updated_at`**：更新时间（自动更新）

**SQL示例**：
```sql
UPDATE procurement_plans 
SET purchase_order_no = 'CGDD2025123001', 
    procurement_status = 'ORDERED',
    updated_at = CURRENT_TIMESTAMP 
WHERE id IN (1, 2);
```

---

## 🎨 用户界面

### 页面设置对话框预览

```
┌─────────────────────────────────────────┐
│ 页面设置                      ✕         │
├─────────────────────────────────────────┤
│ [业务变量] [列字段控制]                 │
├─────────────────────────────────────────┤
│ 业务变量                                 │
│                                          │
│ 采购订单合并规则：                       │
│ ┌──────────────────────────────────┐   │
│ │ 相同供应商，相同承诺回厂日期合并  ▼│   │
│ └──────────────────────────────────┘   │
│                                          │
│ 📝 说明：设置默认的采购订单合并规则，   │
│ 用于一键合并功能                        │
│ • 相同供应商，相同承诺回厂日期合并：    │
│   将相同供应商且承诺回厂日期相同的采购  │
│   计划合并为一个采购订单                │
│ • 如需其他合并规则，请联系周辉         │
│   18627407019                           │
├─────────────────────────────────────────┤
│              [取消]     [保存]          │
└─────────────────────────────────────────┘
```

### 主界面操作流程

```
1. 选择采购计划（勾选多行）
   ↓
2. 选择合并规则下拉框：
   [相同供应商，相同承诺回厂日期合并 ▼]
   ↓
3. 点击 [🔗 一键合并] 按钮
   ↓
4. 确认对话框：
   "将选中的 6 条采购计划按"相同供应商，
   相同承诺回厂日期"合并为采购订单，是否继续？"
   ↓
5. 点击 [确定合并]
   ↓
6. 后端处理：
   - 分组（4组）
   - 生成4个采购订单编号
   - 更新采购计划表
   ↓
7. 成功提示：
   "合并成功！生成了 4 个采购订单"
   ↓
8. 页面刷新，显示最新数据
```

---

## ✅ 测试验证清单

### 功能测试

- [ ] **页面设置对话框**
  - [ ] 点击"页面设置"按钮，对话框正常打开
  - [ ] 业务变量标签页显示合并规则下拉选择器
  - [ ] 列字段控制标签页显示所有字段复选框
  - [ ] 保存按钮能正确保存设置到localStorage
  - [ ] 关闭对话框后主界面下拉框同步更新

- [ ] **列字段控制功能**
  - [ ] 勾选/取消勾选字段后，表格列即时更新
  - [ ] 刷新页面后，列显示设置保持不变
  - [ ] 默认显示所有列

- [ ] **一键合并功能**
  - [ ] 未选择采购计划时，按钮禁用
  - [ ] 选择采购计划后，按钮启用
  - [ ] 点击按钮弹出确认对话框
  - [ ] 确认后调用后端API
  - [ ] 显示正确的成功提示
  - [ ] 采购计划的采购订单编号字段更新
  - [ ] 采购状态更新为"已下单"

### 合并逻辑测试

**测试用例1：同供应商同日期**
- 输入：3条采购计划（供应商A，日期2025-01-15）
- 预期：生成1个采购订单

**测试用例2：不同供应商同日期**
- 输入：2条采购计划（供应商A和B，日期2025-01-15）
- 预期：生成2个采购订单

**测试用例3：同供应商不同日期**
- 输入：2条采购计划（供应商A，日期2025-01-15和2025-01-20）
- 预期：生成2个采购订单

**测试用例4：混合场景**
- 输入：6条采购计划（如上述示例）
- 预期：生成4个采购订单

### 边界测试

- [ ] 仅选择1条采购计划：生成1个订单
- [ ] 选择100+条采购计划：正常处理
- [ ] 供应商名称为空：按`NO_SUPPLIER`分组
- [ ] 承诺回厂日期为空：按`NO_DATE`分组

---

## 🚀 后续扩展建议

### 1. 导出功能
- 导出为Word文档（采购订单格式）
- 导出为PDF（带公司抬头）
- 导出为Excel（采购清单）
- 打印预览功能

### 2. 推送功能
- 企业微信机器人推送
- 钉钉机器人推送
- 微信/QQ机器人推送
- 邮件推送

### 3. 更多合并规则
- 按物料类别合并
- 按紧急程度合并
- 按采购员合并
- 按预算编号合并
- 自定义组合条件合并

### 4. 订单管理
- 采购订单详情页
- 订单状态跟踪
- 订单修改/撤销
- 订单历史记录

---

## 📝 修改文件清单

### 前端文件（3个）
1. **`07-frontend/src/pages/purchase/ProcurementPlanList.vue`** (+189行)
   - 添加页面设置对话框
   - 添加合并规则下拉框
   - 添加一键合并按钮
   - 实现页面设置保存/加载
   - 实现合并订单逻辑

2. **`07-frontend/src/api/procurementPlan.js`** (+10行)
   - 添加mergeToOrder API方法

### 后端文件（2个）
3. **`backend/routes/procurementPlans.js`** (+41行)
   - 添加POST /procurement-plans/merge-to-order路由

4. **`backend/services/procurementPlanService.js`** (+90行)
   - 实现mergeToOrder方法
   - 实现分组算法
   - 实现订单编号生成
   - 实现批量更新逻辑

---

## 🎉 总结

### 已完成功能
✅ 页面设置对话框（业务变量 + 列字段控制）  
✅ 采购订单合并规则下拉选择器  
✅ 一键合并按钮  
✅ 按"相同供应商，相同承诺回厂日期"合并  
✅ 生成采购订单编号（CGDD格式）  
✅ 更新采购计划状态为"已下单"  
✅ 配置持久化（localStorage）  
✅ 后端Service层实现  
✅ 后端路由层实现  
✅ 后端服务已重启生效  

### 用户价值
1. **提升采购效率**：将多条采购计划一键合并为采购订单，减少手动操作
2. **规范采购流程**：统一的合并规则，确保采购订单合理分组
3. **灵活配置**：通过页面设置自定义合并规则和列显示
4. **可扩展性**：为后续导出、推送功能预留接口
5. **用户体验**：友好的提示、确认机制，避免误操作

### 技术亮点
- **前后端分离架构**：清晰的API设计
- **状态持久化**：使用localStorage保存用户配置
- **智能分组算法**：灵活的合并规则引擎
- **事务安全**：批量更新采用占位符防SQL注入
- **日志追踪**：详细的console日志便于调试

---

**报告生成时间**：2025-12-17  
**功能状态**：✅ 已完成并验证  
**后端服务**：✅ 已启动（PID: 3082750）
