# 数据流规则技术实现总结

**生成时间**: 2025-12-15 07:01  
**备份标签**: `backup-before-dataflow-20251215-070121`  
**相关文档**: `备料计划到组装工序计划数据流规则说明.md`

---

## 📋 当前代码状态分析

### 已实现的功能

#### 1. 备料计划Service (materialPreparationPlanService.js)

**✅ 已实现**:
- 第2行: 引入了`RealProcessPlanService`
- 第228-698行: create方法中实现了推送逻辑框架
- 第236-239行: 推送条件检查 (物料来源=自制 && 需补货数量>0)
- 第246-294行: 从产品物料库查询定时工额和定额工时
- 第366-698行: 推送到真工序计划的详细逻辑

**❌ 当前状态**:
- 第843-851行: **推送逻辑被注释禁用了**
- 原因注释: "禁用：备料计划推送到真工序计划（会导致工序能力负荷表已占用工时错误）"

#### 2. 真工序计划Service (realProcessPlanService.js)

**❌ 缺少**:
- 没有找到推送BOM子件回备料计划的逻辑
- 没有`pushToMaterialPlan`方法

#### 3. 组装工序计划Service (assemblyProcessPlanService.js)

**❌ 缺少**:
- 没有找到推送BOM子件回备料计划的逻辑  
- 没有`pushToMaterialPlan`方法

---

## 🎯 需要实现的完整数据流

### 数据流图

```
主生产计划 (执行排程)
    ↓
备料计划Service.create() 
    → 【判断条件】物料来源=自制 && 需补货数量>0 && 来源工序
    → 【路由】
        ├─ 来源工序=打包 → RealProcessPlanService.create()
        ├─ 来源工序=组装 → AssemblyProcessPlanService.create()
        └─ 来源工序=喷塑 → PackingProcessPlanService.create()
    ↓
工序计划Service.create()
    → 【插入数据到对应表】
    → 【查询BOM子件】从产品物料库/生产BOM
    → 【推送子件到备料计划】MaterialPreparationPlanService.create()
    ↓
备料计划Service.create() (第2轮)
    → 【再次判断推送条件】
    → 【递归推送到工序计划】
    ↓
... 循环往复 ...
```

---

## 🔧 技术实现要点

### 1. 备料计划 → 工序计划推送

**文件**: `backend/services/materialPreparationPlanService.js`

**触发时机**: `create`方法中,数据INSERT成功后立即触发

**推送条件判断** (IFS逻辑):
```javascript
const shouldPush = (
  data.planNo &&  // 备料计划编号不为空
  parseFloat(data.replenishmentQuantity || 0) > 0 &&  // 需补货数量 > 0
  data.materialSource === '自制' &&  // 物料来源 = 自制
  (data.sourceProcess === '打包' || data.sourceProcess === '组装' || data.sourceProcess === '喷塑')  // 来源工序
);
```

**推送路由规则**:
```javascript
if (shouldPush) {
  if (data.sourceProcess === '打包') {
    // 推送到打包工序计划 (真工序计划表)
    await RealProcessPlanService.create({
      planNo: generatePlanNo('RPP'),  // 工序计划编号
      sourceNo: data.planNo,  // 来源编号 = 备料计划编号
      productCode: data.materialCode,  // 生产产品编号
      productName: data.materialName,  // 生产产品名称
      replenishmentQty: data.replenishmentQuantity,  // 需补货数量
      mainPlanProductCode: data.mainPlanProductCode,  // 主计划产品编号
      customerOrderNo: data.customerOrderNo,  // 客户订单编号
      salesOrderNo: data.salesOrderNo,  // 销售订单编号
      processName: data.sourceProcess,  // 工序名称 = 打包
      // ... 其他字段映射
    });
  } else if (data.sourceProcess === '组装') {
    // 推送到组装工序计划表
    await AssemblyProcessPlanService.create({...});
  } else if (data.sourceProcess === '喷塑') {
    // 推送到喷塑工序计划表
    await PackingProcessPlanService.create({...});
  }
}
```

### 2. 工序计划 → 备料计划推送

**文件**: 
- `backend/services/realProcessPlanService.js`
- `backend/services/assemblyProcessPlanService.js`
- `backend/services/packingProcessPlanService.js`

**触发时机**: `create`方法中,工序计划数据INSERT成功后立即触发

**步骤**:

#### 步骤1: 查询BOM子件

```javascript
// 方案A: 从BOM详情字段中提取 (优先)
const bomDetail = data.bomDetail;  // 假设是JSON字符串
const bomItems = JSON.parse(bomDetail || '[]');

// 方案B: 查询列表式生产BOM
const [bomRows] = await connection.execute(`
  SELECT 
    component_code as childCode,
    component_name as childName,
    component_qty as childQty,
    component_unit as childUnit,
    component_source as childSource,
    output_process as childProcess
  FROM list_style_production_bom
  WHERE parent_code = ?
`, [data.productCode]);
```

#### 步骤2: 遍历子件推送到备料计划

```javascript
for (const item of bomItems) {
  // 创建备料计划
  await MaterialPreparationPlanService.create({
    planNo: generatePlanNo('BL'),  // 备料计划编号
    sourceProcessPlanNo: data.planNo,  // 来源工序计划编号
    parentCode: data.productCode,  // 父件编号
    parentName: data.productName,  // 父件名称
    parentScheduleQuantity: data.scheduleQuantity,  // 父件排程数量
    materialCode: item.childCode,  // 备料物料编号
    materialName: item.childName,  // 备料物料名称
    materialSource: item.childSource,  // 物料来源 (自制/外协/采购)
    sourceProcess: item.childProcess,  // 来源工序 (打包/组装/喷塑)
    demandQuantity: item.childQty * data.scheduleQuantity,  // 需求数量
    mainPlanProductCode: data.mainPlanProductCode,  // 主计划产品编号
    customerOrderNo: data.customerOrderNo,  // 客户订单编号
    salesOrderNo: data.salesOrderNo,  // 销售订单编号
    // ... 其他字段
  });
}
```

### 3. 递归控制

**终止条件**:

1. **需补货数量 ≤ 0**: 不推送
2. **物料来源 != "自制"**: 不推送 (采购件、外协件)
3. **BOM子件为空**: 到达叶子节点,自然终止
4. **来源工序不匹配**: 不是打包/组装/喷塑,不推送

**防止死循环**:
- 每次推送都基于新的备料计划编号
- BOM层级有限,最终必然到达叶子节点
- 需补货数量会逐级分解

---

## 📊 6001A0306 完整数据流验证

### 预期数据流

```
第1轮:
主生产计划(6001A0306, qty=10)
    ↓
备料计划(bl01: 6001A0306, 来源工序=打包, 需补货=10)
    ↓ [IFS判断: ✅ 自制 && 10>0 && 打包]
打包工序计划(RPP001: 6001A0306, 来源编号=bl01)

第2轮:
打包工序计划(RPP001)
    ↓ [查询BOM子件: 470001A, 470002A, 511442B]
    ↓
备料计划(bl02: 470001A, 来源工序=组装, 需补货=5)
备料计划(bl03: 470002A, 来源工序=组装, 需补货=3)
备料计划(bl04: 511442B, 来源工序=采购, 需补货=20)
    ↓ [IFS判断]
    ├─ bl02: ✅ → 组装工序计划(ASP001)
    ├─ bl03: ✅ → 组装工序计划(ASP002)
    └─ bl04: ❌ (采购件) → 不推送

第3轮:
组装工序计划(ASP001, ASP002)
    ↓ [查询470001A, 470002A的BOM子件]
    ↓
备料计划(bl05, bl06, bl07...)
    ↓ [继续递归]
...
```

---

## ✅ 实施建议

### 优先级1: 启用备料计划推送逻辑

**修改文件**: `backend/services/materialPreparationPlanService.js`

**操作**:
1. 取消第843-851行的注释
2. 修改推送逻辑,支持路由到不同工序计划
3. 添加AssemblyProcessPlanService和PackingProcessPlanService的引入

### 优先级2: 实现工序计划推送BOM子件

**新增方法**:
- `RealProcessPlanService.pushToMaterialPlan()`
- `AssemblyProcessPlanService.pushToMaterialPlan()`
- `PackingProcessPlanService.pushToMaterialPlan()`

**在create方法中调用**:
```javascript
static async create(data) {
  // ... 插入工序计划数据 ...
  
  const insertedId = result.insertId;
  
  // ✅ 立即推送BOM子件到备料计划
  await this.pushToMaterialPlan(insertedId, data);
  
  return { id: insertedId, planNo: data.planNo };
}
```

### 优先级3: 测试验证

1. 清空测试数据
2. 创建6001A0306销售订单
3. 执行主生产计划排程
4. 验证数据流各个环节

---

## ⚠️ 注意事项

### 1. 循环依赖问题

**问题**: MaterialPreparationPlanService ↔ RealProcessPlanService 相互引用

**解决方案**:
- 使用延迟加载: `const RealProcessPlanService = require('./realProcessPlanService');`
- 或使用中间层Service避免直接循环引用

### 2. 事务管理

**问题**: 多层嵌套调用,事务冲突

**解决方案**:
- 每个Service的create方法独立开启事务
- 推送逻辑不复用同一个connection
- 推送失败不影响主数据创建

### 3. 性能优化

**问题**: 递归推送可能导致大量数据库操作

**优化方案**:
- 批量插入BOM子件到备料计划
- 异步推送,不阻塞主流程
- 添加推送队列机制

---

## 📝 总结

### 当前状态

- ✅ 备料计划 → 工序计划推送逻辑已实现 (但被禁用)
- ❌ 工序计划 → 备料计划推送逻辑缺失
- ❌ 递归数据流未完整实现

### 需要补充

1. 启用并完善备料计划推送逻辑
2. 实现工序计划推送BOM子件逻辑
3. 添加AssemblyProcessPlanService和PackingProcessPlanService支持
4. 完整测试递归数据流

### 预期效果

- ✅ 主生产计划 → 备料计划 → 工序计划 → 备料计划 ... 自动递归
- ✅ 基于IFS条件精确路由到不同工序计划表
- ✅ 数据流自动终止,无需手动干预
- ✅ 6001A0306完整分解到所有层级BOM子件

---

**报告结束** ✨

**下一步行动**: 
1. 用户确认理解数据流规则
2. 决定是否立即实施代码修改
3. 或先进行现有代码测试验证
