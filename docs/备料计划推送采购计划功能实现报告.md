# 备料计划推送采购计划功能实现报告

**实现日期**: 2025-12-17  
**功能类型**: 数据流水线 - 新增+更新双重规则  
**涉及模块**: 备料计划、采购计划

---

## 📋 需求概述

### 功能目标
实现备料计划自动推送到采购计划的**新增+更新双重规则**，支持以下三种备料计划的新增方式：

1. **方式a**：生产计划列表自动推送到备料计划生成
2. **方式b**：工序计划推送到备料计划
3. **方式c**：备料计划点击"新增"按钮新增

### 触发条件
只要备料计划数据行生成，立即检查以下条件：
- ✅ 备料计划编号不为空
- ✅ "来源工序" = "采购"
- ✅ "需补货数量" > 0

**触发时机**：备料计划编号生成时立即触发

---

## 🔍 推送规则详解

### 规则A：更新规则（优先执行）

#### 查询条件
```sql
AND(
  目标页面的"销售订单编号" = 来源表格的"销售订单编号",
  目标页面的"采购物料编号" = 来源表格的"备料物料编号"
)
```

#### 查询结果：有符合条件 → 执行更新

**数据流映射**（"=" 左边是目标表格，右边是来源表格）：

| 字段序号 | 目标字段 | 更新规则 |
|---------|---------|---------|
| 1 | 采购计划编号 | **不变** |
| 2 | 采购订单编号 | **不变** |
| 3 | 来源表单 | = "备料计划" |
| 4 | 来源编号 | = textjoin(目标表格的"来源编号", "-", 来源表格的"备料计划编号&":"&需补货数量") |
| 14 | 采购物料编号 | **不变** |
| 15 | 采购物料名称 | **不变** |
| 16 | 图片 | **不变** |
| 17 | 需补货数量 | = 目标表格的需补货数量 + 来源表格的需补货数量 |
| 18 | 基本单位 | **不变** |
| 19 | 销售订单编号 | **不变** |
| 20 | 客户订单编号 | **不变** |
| 21 | 主生产计划编号 | = textjoin(目标表格的"主生产计划编号", 来源表格的"来源主计划编号") **去重复** |
| 22 | 工序计划编号 | = textjoin(目标表格的"工序计划编号", 来源表格的"来源工序计划编号") **去重复** |
| 23 | 备料计划编号 | **不变** |
| 24 | 采购提前期 | **不变** |
| 24 | 计划到货日期 | = min(目标表格的"计划到货日期", 需求日期 - 采购提前期) |

**更新示例**：

**示例1：来源编号拼接**
```
更新前：bl01:20
触发：备料计划编号=bl02, 需补货数量=100
更新后：bl01:20, bl02:100
```

**示例2：需补货数量累加**
```
更新前：需补货数量=100
来源：需补货数量=50
更新后：需补货数量=150
```

**示例3：主计划编号去重**
```
更新前：ZJH01
来源：ZJH01
更新后：ZJH01（去重）

更新前：ZJH01
来源：ZJH02
更新后：ZJH01, ZJH02
```

**示例4：计划到货日期取最小值**
```
更新前：10/6
来源：需求日期=10/20, 采购提前期=3
计算：10/20 - 3 = 10/17
更新后：min(10/6, 10/17) = 10/6
```

---

### 规则B：新增规则（查询结果为null时执行）

#### 查询条件
```sql
AND(
  目标页面的"销售订单编号" = 来源表格的"销售订单编号",
  目标页面的"采购物料编号" = 来源表格的"备料物料编号"
)
```

#### 查询结果：null → 执行新增

**数据流映射**：

| 字段序号 | 目标字段 | 新增规则 |
|---------|---------|---------|
| 1 | 采购计划编号 | 系统自动生成（CGGH + 年份 + 时间戳 + 随机数） |
| 2 | 采购订单编号 | 暂为空 |
| 3 | 来源表单 | = "备料计划" |
| 4 | 来源编号 | = 备料计划编号 |
| 14 | 采购物料编号 | = 备料物料编号 |
| 15 | 采购物料名称 | = 备料物料名称 |
| 16 | 图片 | = null |
| 17 | 需补货数量 | = 需补货数量 |
| 18 | 基本单位 | = 物料单位 |
| 19 | 销售订单编号 | = 销售订单编号 |
| 20 | 客户订单编号 | = 客户订单编号 |
| 21 | 主生产计划编号 | = 来源主计划编号 |
| 22 | 工序计划编号 | = 来源工序计划编号 |
| 23 | 备料计划编号 | = 备料计划编号 |
| 24 | 采购提前期 | = lookup(产品物料库.物料编码 = 采购物料编号, 产品物料库."默认采购提前期") |
| 24 | 需求日期 | = 备料计划.需求日期 |
| 24 | 计划到货日期 | = 需求日期 - 采购提前期 |

**前置条件**：
- 采购提前期Lookup：采购物料编号生成且不为空
- 计划到货日期计算：采购提前期不为空

---

## 💻 技术实现

### 1. 数据库表结构变更

#### procurement_plans表新增字段
```sql
ALTER TABLE procurement_plans 
ADD COLUMN procurement_lead_time INT DEFAULT 3 COMMENT '采购提前期(天)' AFTER material_plan_no,
ADD COLUMN demand_date DATE COMMENT '需求日期' AFTER procurement_lead_time;
```

#### materials表新增字段
```sql
ALTER TABLE materials 
ADD COLUMN default_procurement_lead_time INT DEFAULT 3 COMMENT '默认采购提前期(天)' AFTER purchase_cycle;
```

**状态**：✅ 字段已成功添加

---

### 2. 后端服务实现

#### 文件修改列表

| 文件路径 | 修改内容 | 行数变化 |
|---------|---------|---------|
| `backend/services/materialPreparationPlanService.js` | 新增推送到采购计划逻辑 | +236行 |
| `backend/services/procurementPlanService.js` | 更新字段映射和create方法 | +5行 |

#### 核心方法：pushToProcurementPlan

**位置**：`backend/services/materialPreparationPlanService.js` 第842-1050行

**逻辑流程**：
```javascript
1. 检查触发条件
   └─ planNo存在 && sourceProcess==='采购' && replenishmentQty > 0

2. 查询现有采购计划
   └─ WHERE sales_order_no = ? AND material_code = ?

3. 如果存在（执行更新规则）
   ├─ 拼接来源编号（textjoin + 去重）
   ├─ 累加需补货数量
   ├─ 合并主计划编号（textjoin + 去重）
   ├─ 合并工序计划编号（textjoin + 去重）
   ├─ 取最小计划到货日期
   └─ UPDATE procurement_plans

4. 如果不存在（执行新增规则）
   ├─ 生成采购计划编号（CGGH + 时间戳）
   ├─ Lookup采购提前期（从materials表）
   ├─ 计算计划到货日期（需求日期 - 采购提前期）
   └─ INSERT INTO procurement_plans
```

---

### 3. 触发机制集成

#### 备料计划create方法集成

**位置**：`backend/services/materialPreparationPlanService.js` 第229-260行

**触发代码**：
```javascript
// ✅ 新增：自动推送到采购计划（在事务提交后）
if (data.planNo && data.sourceProcess === '采购') {
  const demandQty = parseFloat(data.demandQuantity || 0);
  const availableQty = parseFloat(data.availableStock || 0);
  const replenishmentQty = demandQty - availableQty;
  
  if (replenishmentQty > 0) {
    console.log('🛒 备料计划创建成功，来源工序=采购，开始自动推送到采购计划...');
    
    try {
      const pushResult = await this.pushToProcurementPlan(data);
      
      if (pushResult && pushResult.success) {
        console.log(`✅ 推送采购计划成功: ${data.planNo} → 采购计划 (${pushResult.procurementPlanNo})`);
        
        // 更新推送状态
        await pool.execute(
          'UPDATE material_preparation_plans SET push_to_purchase = ? WHERE plan_no = ?',
          [1, data.planNo]
        );
      }
    } catch (pushError) {
      console.error(`❌ 推送采购计划失败:`, pushError.message);
    }
  }
}
```

**特点**：
- ✅ 事务提交后执行（避免数据不一致）
- ✅ 异步处理（不阻塞主流程）
- ✅ 错误捕获（推送失败不影响备料计划创建）
- ✅ 状态更新（push_to_purchase字段标记）

---

## 📊 数据流水线示意图

```
备料计划创建（3种方式）
    │
    ├─ 方式a: 生产计划 → 备料计划
    ├─ 方式b: 工序计划 → 备料计划
    └─ 方式c: 手动新增 → 备料计划
          │
          ├─ 检查：来源工序 = "自制"？
          │   └─ YES → 推送到工序计划
          │
          └─ 检查：来源工序 = "采购"？
              └─ YES → 推送到采购计划
                    │
                    ├─ 查询：已存在相同销售订单+物料？
                    │   │
                    │   ├─ YES → 执行更新规则
                    │   │      ├─ 拼接来源编号
                    │   │      ├─ 累加需补货数量
                    │   │      ├─ 合并计划编号（去重）
                    │   │      └─ 取最小到货日期
                    │   │
                    │   └─ NO → 执行新增规则
                    │          ├─ 生成采购计划编号
                    │          ├─ Lookup采购提前期
                    │          └─ 计算计划到货日期
                    │
                    └─ 更新推送状态（push_to_purchase=1）
```

---

## 🧪 测试验证清单

### 测试场景1：新增规则验证

**步骤**：
1. 创建备料计划
   - 来源工序 = "采购"
   - 备料物料编号 = "MATERIAL001"
   - 销售订单编号 = "SO20251217001"
   - 需补货数量 = 100
   - 需求日期 = 2025-12-25

2. 检查采购计划
   - [ ] 自动生成采购计划编号（格式：CGGH2025xxxxxx）
   - [ ] 来源表单 = "备料计划"
   - [ ] 来源编号 = 备料计划编号
   - [ ] 采购物料编号 = MATERIAL001
   - [ ] 需补货数量 = 100
   - [ ] 采购提前期 = 从materials表lookup（默认3天）
   - [ ] 计划到货日期 = 2025-12-22（2025-12-25 - 3天）

---

### 测试场景2：更新规则验证

**步骤**：
1. 已存在采购计划
   - 销售订单编号 = "SO20251217001"
   - 采购物料编号 = "MATERIAL001"
   - 来源编号 = "BL001:50"
   - 需补货数量 = 50
   - 计划到货日期 = 2025-12-20

2. 创建第二个备料计划
   - 来源工序 = "采购"
   - 备料物料编号 = "MATERIAL001"
   - 销售订单编号 = "SO20251217001"
   - 备料计划编号 = "BL002"
   - 需补货数量 = 30
   - 需求日期 = 2025-12-25

3. 检查采购计划更新
   - [ ] 来源编号 = "BL001:50, BL002:30"
   - [ ] 需补货数量 = 80（50 + 30）
   - [ ] 计划到货日期 = 2025-12-20（min(2025-12-20, 2025-12-22)）

---

### 测试场景3：主计划编号去重验证

**步骤**：
1. 已存在采购计划
   - 主生产计划编号 = "ZJH001"

2. 创建备料计划
   - 来源主计划编号 = "ZJH001"

3. 检查更新
   - [ ] 主生产计划编号 = "ZJH001"（去重后只保留一个）

4. 创建第二个备料计划
   - 来源主计划编号 = "ZJH002"

5. 检查更新
   - [ ] 主生产计划编号 = "ZJH001, ZJH002"（两个不同的计划）

---

### 测试场景4：推送状态验证

**步骤**：
1. 创建备料计划（来源工序="采购"，需补货数量>0）
2. 检查备料计划表
   - [ ] push_to_purchase = 1（推送成功标记）

---

## ⚠️ 注意事项

### 1. 数据一致性
- ✅ 使用事务保证原子性
- ✅ 更新规则使用数据库事务
- ✅ 推送失败不影响备料计划创建

### 2. 字段命名
- `备料物料编号` → `material_code` (数据库)
- `来源主计划编号` → `mainPlanProductCode` 或 `sourcePlanNo` (代码)
- `需求日期` → `demandDate` → `demand_date` (数据库)

### 3. 默认值处理
- 采购提前期：默认3天（从materials表lookup，找不到则使用默认值）
- 图片：新增时默认为null
- 采购订单编号：新增时为空（待后续填写）

### 4. 性能优化
- 异步推送（不阻塞备料计划创建）
- 单次查询（避免重复数据库访问）
- 索引优化（sales_order_no + material_code建立复合索引）

---

## 🎯 后续建议

### 1. 性能优化
- [ ] 为`procurement_plans`表的`(sales_order_no, material_code)`建立复合索引
- [ ] 监控推送性能，必要时加入批量推送机制

### 2. 功能增强
- [ ] 添加采购计划推送日志表
- [ ] 前端显示推送状态和历史记录
- [ ] 支持手动重新推送功能

### 3. 数据验证
- [ ] 添加采购提前期合理性校验（1-365天）
- [ ] 计划到货日期不能早于当前日期的警告

### 4. 监控告警
- [ ] 推送失败时发送通知
- [ ] 定期检查未推送的备料计划

---

## ✅ 实现完成确认

- [x] 数据库表结构变更完成
- [x] 后端Service层代码实现
- [x] 新增规则实现
- [x] 更新规则实现
- [x] 去重逻辑实现
- [x] Lookup采购提前期
- [x] 计算计划到货日期
- [x] 推送状态标记
- [x] 错误处理机制
- [x] 后端服务重启
- [ ] 前端测试验证（需用户执行）
- [ ] 完整数据流测试（需用户执行）

---

**报告生成时间**: 2025-12-17 16:35  
**报告版本**: v1.0  
**下一步操作**: 请用户在浏览器中进行完整的数据流测试
