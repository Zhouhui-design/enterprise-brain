# 正式下单多产品订单修复报告

## 🐛 问题描述

### 用户反馈的问题

1. 一个订单有2个产品（6001A0306、6002A0203）
2. 正式下单后，主生产计划只创建了1条数据（6001A0306）
3. 另一个产品（6002A0203）没有生成主生产计划

### 问题现象

```
订单：SO202512070001
  ├─ 产品1: 6001A0306  ✅ 生成主生产计划
  └─ 产品2: 6002A0203  ❌ 未生成主生产计划
```

---

## 🔍 问题原因分析

### 根本原因

订单列表是**按产品展开显示**的（每个产品一行）。当用户勾选订单时，`selectedRows`包含的是**展开后的行**，而不是原始订单对象。

### 数据结构示例

**订单列表展开显示**：
```javascript
// 一个订单有2个产品，在表格中显示为2行
[
  { id: "order-123", internalOrderNo: "SO001", productCode: "6001A0306", ... },
  { id: "order-123", internalOrderNo: "SO001", productCode: "6002A0203", ... }
]
```

**之前的错误逻辑**：
```javascript
// ❌ 错误：把展开的每一行当作一个独立订单处理
const salesOrders = selectedRows.value.map(order => {
  // 每一行只有一个productCode
  // 导致products数组只包含当前行的产品
  if (products.length === 0 && order.productCode) {
    products = [{ productCode: order.productCode, ... }] // ❌ 只有1个产品
  }
  return { products }
})

// 结果：
// salesOrders = [
//   { id: "order-123", products: [{ productCode: "6001A0306" }] },  // 第1行
//   { id: "order-123", products: [{ productCode: "6002A0203" }] }   // 第2行
// ]
// 
// 问题：同一个订单被当作2个订单处理！
```

### 为什么只创建了1个主生产计划？

虽然前端发送了2个订单对象（实际是同一个订单的2行），但由于某些原因（可能是去重逻辑或其他错误），后端只处理了第1个。

---

## 🛠️ 解决方案

### 修复策略

**正确的逻辑**：
1. 按订单ID去重，收集同一订单的所有产品
2. 为每个唯一订单构造完整的产品列表
3. 发送到后端创建主生产计划

### 修复代码

**文件**: `/07-frontend/src/pages/sales/sales-order/SalesOrderListNew.vue`

**修改位置**: 第1215-1253行

```javascript
// ⚠️ 重要：订单列表是按产品展开的，需要先按订单ID去重，收集同一订单的所有产品
const orderMap = new Map()

selectedRows.value.forEach(row => {
  const orderId = row.id
  
  if (!orderMap.has(orderId)) {
    // 第一次遇到这个订单，初始化订单数据
    orderMap.set(orderId, {
      id: orderId,
      internalOrderNo: row.internalOrderNo,
      customerOrderNo: row.customerOrderNo,
      salesperson: row.salesperson,
      customerDeliveryDate: row.customerDelivery,
      promisedDeliveryDate: row.promisedDelivery,
      products: []
    })
  }
  
  // 添加当前产品到订单的产品列表
  if (row.productCode) {
    orderMap.get(orderId).products.push({
      productCode: row.productCode,
      productName: row.productName,
      orderQuantity: row.orderQuantity,
      productUnit: row.productUnit,
      productImage: row.productImage,
      outputProcess: row.outputProcess || ''
    })
  }
})

// 转换为数组
const salesOrders = Array.from(orderMap.values())

console.log('📦 整理后的订单数据:', salesOrders.map(o => ({
  internalOrderNo: o.internalOrderNo,
  产品数量: o.products.length,
  产品编码: o.products.map(p => p.productCode)
})))
```

---

## 📊 修复前后对比

### 修复前

```javascript
// 选中的行（展开后）
selectedRows = [
  { id: "order-123", productCode: "6001A0306" },
  { id: "order-123", productCode: "6002A0203" }
]

// 构造的数据（错误）
salesOrders = [
  { 
    id: "order-123", 
    products: [{ productCode: "6001A0306" }]  // ❌ 只有1个产品
  },
  { 
    id: "order-123", 
    products: [{ productCode: "6002A0203" }]  // ❌ 只有1个产品
  }
]

// 结果：后端只处理了第1个，只创建了1条主生产计划
```

### 修复后

```javascript
// 选中的行（展开后）
selectedRows = [
  { id: "order-123", productCode: "6001A0306" },
  { id: "order-123", productCode: "6002A0203" }
]

// 构造的数据（正确）
salesOrders = [
  { 
    id: "order-123", 
    products: [
      { productCode: "6001A0306" },  // ✅ 产品1
      { productCode: "6002A0203" }   // ✅ 产品2
    ]
  }
]

// 结果：后端正确处理，为2个产品各创建1条主生产计划
```

---

## 🧪 测试验证

### 测试步骤

1. **清空浏览器缓存**（Ctrl+Shift+Delete）

2. **刷新订单列表页面**

3. **新增订单**：
   - 产品1：6001A0306
   - 产品2：6002A0203

4. **正式下单**：
   - 选择刚创建的订单（会选中2行）
   - 点击"正式下单"按钮
   - 弹窗提示应显示："确定要对选中的 **1** 个订单执行正式下单吗？"（而不是2个）

5. **验证主生产计划**：
   - 访问主生产计划页面
   - 应该看到**2条**主生产计划记录：
     - MPS2025120700XX - 6001A0306
     - MPS2025120700YY - 6002A0203

### 预期控制台日志

```javascript
📋 开始正式下单流程，选中订单数: 2  // 选中了2行

📦 整理后的订单数据: [
  {
    internalOrderNo: "SO202512070001",
    产品数量: 2,                    // ✅ 2个产品
    产品编码: ["6001A0306", "6002A0203"]
  }
]

📝 从销售订单创建主生产计划，数量: 1  // ✅ 1个订单

📝 创建主生产计划: { productCode: "6001A0306", ... }
📝 创建主生产计划: { productCode: "6002A0203", ... }

✅ 主生产计划创建成功
```

---

## 🎯 关键改进点

### 1. 数据去重

**之前**：
- 勾选2行 → 发送2个订单对象
- 同一订单ID被重复处理

**现在**：
- 勾选2行 → 按ID去重 → 合并为1个订单对象
- 每个订单只发送1次

### 2. 产品列表完整性

**之前**：
- 每个订单对象只包含当前行的1个产品
- products = [{ productCode: "6001A0306" }]

**现在**：
- 订单对象包含所有产品
- products = [
    { productCode: "6001A0306" },
    { productCode: "6002A0203" }
  ]

### 3. 日志优化

添加了清晰的日志输出，方便调试：
- 整理后的订单数据
- 每个订单的产品数量
- 每个订单的产品编码列表

---

## 📋 相关代码修改

### 修改文件清单

- ✅ `/07-frontend/src/pages/sales/sales-order/SalesOrderListNew.vue`
  - 第1215-1253行：重写订单数据构造逻辑
  - 使用Map进行订单去重
  - 收集同一订单的所有产品

### 代码行数变化

- **删除**: 59行（旧的复杂解析逻辑）
- **新增**: 35行（简洁的去重合并逻辑）
- **净减少**: 24行

---

## ⚠️ 注意事项

### 1. 订单选择逻辑

由于订单是按产品展开的，用户勾选订单时：
- 勾选第1个产品行 → 选中订单的第1个产品
- 勾选第2个产品行 → 选中订单的第2个产品
- **必须勾选所有产品行**才能完整下单

**建议优化**：
- 添加"全选订单"功能（按订单ID分组，一次性勾选所有产品）
- 或者在单元格合并区域添加勾选框（点击订单主字段即勾选所有产品）

### 2. 弹窗提示

修复后，弹窗提示应显示：
- "确定要对选中的 **1** 个订单执行正式下单吗？"（而不是"2个订单"）
- 因为实际是1个订单，只是有2个产品

---

## 🚀 后续优化建议

### 1. 订单勾选体验优化

**当前问题**：
- 用户需要分别勾选同一订单的每个产品行
- 容易漏选，导致只下单部分产品

**建议方案**：
- 在订单主字段合并区域添加勾选框
- 点击主字段勾选框 → 自动勾选该订单的所有产品行
- 类似Excel的"全选组"功能

### 2. 订单状态校验

**当前状态**：
- 已临时移除状态校验（允许所有订单正式下单）
- 参考记忆：`正式下单状态校验临时移除`

**建议**：
- 模拟排程功能完成后，恢复状态校验
- 只允许"待下单"或"已模拟排程待下单"状态的订单正式下单

### 3. 订单ID重复处理

**潜在风险**：
- 如果用户同时勾选了多个不同订单的产品行
- 需要确保每个订单的产品正确归类

**当前方案已解决**：
- 使用Map按订单ID分组
- 自动处理多订单多产品场景

---

## 📞 技术支持

### 问题排查

1. **主生产计划仍然只有1条**
   - 清空浏览器缓存
   - 检查控制台日志："整理后的订单数据"
   - 确认产品数量是否为2

2. **弹窗仍显示"2个订单"**
   - 确认前端代码已更新
   - 刷新页面（Ctrl+F5）

3. **后端错误**
   - 查看backend.log
   - 确认后端接收到的products数组

### 数据库验证

```sql
-- 查看主生产计划
SELECT 
  plan_code, 
  product_code, 
  product_name,
  internal_order_no
FROM master_production_plans
WHERE internal_order_no = 'SO202512070001'
ORDER BY created_at DESC;

-- 应该返回2条记录
```

---

**修复时间**: 2025-12-07 15:20  
**修复人员**: AI Assistant  
**影响范围**: 销售订单正式下单流程（多产品订单）  
**风险等级**: 低（仅优化前端数据处理逻辑）  
**测试状态**: 待用户验证
