# 工序能力负荷表数据流水线完整实现

## 实施时间
2025-12-08 17:30 - 18:00

---

## 需求概述

### 触发页面
- 工序页面 (`http://localhost:3002/manufacturing/process`)

### 目标页面
- 工序能力负荷表 (`http://localhost:3002/mrp/capacity-load`)

### 触发时机
- 至少选择一个工序
- 点击"加载到工序能力负荷表"按钮

### 触发条件
- 至少选择一个工序
- 且"自制/外协" = "自制"

---

## 数据流规则

| 目标字段 | 来源/计算规则 |
|---------|---------------|
| 工序名称 | 工序页面.工序名称 |
| 日期 | 最小日期=系统当天日期，最大日期=系统当天日期+显示天数 |
| 可用工位数量 | 工序页面.可用工位数量 |
| 上班时段 | 暂为空（可手动录入） |
| 已占用工时 | 暂为空（可手动录入） |
| 剩余时段 | 暂为空（可手动录入） |
| 剩余工时 | 暂为空（可手动录入） |
| 加班时段 | 自由录入 |

### 日期生成规则
- 每个工序未来N天的日期都要在工序能力负荷表中显示
- N = 显示天数（业务变量，默认120天，可在页面设置中修改）
- 整个表格按日期从小到大排序

### 自动更新机制
- 每天凌晨0:00自动更新
- 更新内容：
  1. 删除早于系统当天日期的数据
  2. 为所有已加载工序补充新的日期数据
  3. 确保每个工序都有未来N天的完整数据

---

## 实施步骤

### 步骤1: 数据库表设计

#### 1.1 工序能力负荷表
```sql
CREATE TABLE IF NOT EXISTS process_capacity_load (
  id INT PRIMARY KEY AUTO_INCREMENT,
  process_name VARCHAR(100) NOT NULL COMMENT '工序名称',
  date DATE NOT NULL COMMENT '日期',
  available_workstations INT DEFAULT 0 COMMENT '可用工位数量',
  work_shift VARCHAR(255) DEFAULT NULL COMMENT '上班时段',
  occupied_hours DECIMAL(10,2) DEFAULT 0 COMMENT '已占用工时',
  remaining_shift VARCHAR(255) DEFAULT NULL COMMENT '剩余时段',
  remaining_hours DECIMAL(10,2) DEFAULT 0 COMMENT '剩余工时',
  overtime_shift VARCHAR(255) DEFAULT NULL COMMENT '加班时段',
  created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
  updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
  UNIQUE KEY unique_process_date (process_name, date),
  INDEX idx_date (date),
  INDEX idx_process_name (process_name)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;
```

**关键设计**:
- `UNIQUE KEY unique_process_date`: 确保同一工序+同一日期只有一条记录
- `INDEX idx_date`: 优化日期查询性能
- `INDEX idx_process_name`: 优化工序名称查询性能

#### 1.2 页面设置表
```sql
CREATE TABLE IF NOT EXISTS page_settings (
  id INT PRIMARY KEY AUTO_INCREMENT,
  page_key VARCHAR(100) NOT NULL COMMENT '页面标识',
  setting_key VARCHAR(100) NOT NULL COMMENT '设置键',
  setting_value TEXT COMMENT '设置值',
  created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
  updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
  UNIQUE KEY unique_page_setting (page_key, setting_key)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;

-- 插入默认显示天数配置
INSERT INTO page_settings (page_key, setting_key, setting_value)
VALUES ('capacity-load', 'displayDays', '120')
ON DUPLICATE KEY UPDATE setting_value = '120';
```

---

### 步骤2: 后端API实现

**文件**: `/backend/routes/capacityLoad.js`

#### 2.1 核心接口

##### GET `/api/capacity-load/list` - 获取列表
```javascript
// 返回所有工序能力负荷数据，按日期升序排序
const [rows] = await pool.execute(
  'SELECT * FROM process_capacity_load ORDER BY date ASC, process_name ASC'
);
```

##### POST `/api/capacity-load/load-from-processes` - 从工序加载
```javascript
// 1. 校验至少选择一个工序
// 2. 获取显示天数配置
// 3. 为每个工序生成未来N天的数据
// 4. 使用INSERT ... ON DUPLICATE KEY UPDATE避免重复
```

**关键代码**:
```javascript
const displayDays = settingRows.length > 0 ? parseInt(settingRows[0].setting_value) : 120;
const today = new Date();
today.setHours(0, 0, 0, 0);

for (const process of processes) {
  for (let i = 0; i < displayDays; i++) {
    const currentDate = new Date(today);
    currentDate.setDate(today.getDate() + i);
    const dateStr = currentDate.toISOString().split('T')[0];
    
    await connection.execute(`
      INSERT INTO process_capacity_load (...)
      VALUES (...)
      ON DUPLICATE KEY UPDATE available_workstations = VALUES(available_workstations)
    `, [processName, dateStr, availableWorkstations || 0]);
  }
}
```

##### GET `/api/capacity-load/settings/:pageKey` - 获取页面设置
```javascript
// 返回指定页面的所有设置项（如displayDays）
```

##### POST `/api/capacity-load/settings/:pageKey` - 保存页面设置
```javascript
// 保存或更新页面设置（支持修改显示天数）
```

##### PUT `/api/capacity-load/update/:id` - 更新单条记录
```javascript
// 更新工序能力负荷表的可编辑字段
// 包括：上班时段、已占用工时、剩余时段、剩余工时、加班时段
```

---

### 步骤3: 前端工序页面修改

**文件**: `/07-frontend/src/pages/manufacturing/ProcessList.vue`

#### 3.1 添加按钮工具栏
```vue
<div class="toolbar" style="margin: 20px 0; display: flex; gap: 10px;">
  <el-button type="primary" @click="handleCreate">新增工序</el-button>
  <el-button type="danger" :disabled="selectedRows.length === 0" @click="handleBatchDelete">批量删除</el-button>
  <el-button type="success" :disabled="selectedRows.length === 0" @click="handleLoadToCapacityTable">加载到工序能力负荷表</el-button>
  <el-button @click="handleImport">导入</el-button>
  <el-button @click="handleExport">导出</el-button>
  <el-button @click="handlePrint">打印</el-button>
</div>
```

#### 3.2 实现加载函数
```javascript
const handleLoadToCapacityTable = async () => {
  // 1. 筛选出"自制/外协" = "自制"的工序
  const selfMadeProcesses = selectedRows.value.filter(row => row.selfOrOutsource === '自制')
  
  // 2. 验证至少选择一个自制工序
  if (selfMadeProcesses.length === 0) {
    ElMessage.warning('请选择至少一个"自制/外协" 为 "自制" 的工序')
    return
  }
  
  // 3. 显示确认对话框
  await ElMessageBox.confirm(
    `共选择了 ${selectedRows.value.length} 个工序，其中 ${selfMadeProcesses.length} 个为"自制"工序。确定加载到工序能力负荷表吗？`,
    '提示'
  )
  
  // 4. 准备数据并调用API
  const processes = selfMadeProcesses.map(row => ({
    processName: row.processName,
    availableWorkstations: row.availableWorkstations || 0
  }))
  
  const response = await fetch('http://192.168.2.229:3005/api/capacity-load/load-from-processes', {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify({ processes })
  })
  
  // 5. 处理响应
  const result = await response.json()
  if (result.code === 200) {
    ElMessage.success(result.message)
    selectedRows.value = []
  }
}
```

---

### 步骤4: 工序能力负荷表页面

**文件**: `/07-frontend/src/pages/mrp/CapacityLoad.vue`

#### 4.1 页面结构
```vue
<template>
  <div class="capacity-load-container">
    <h2>工序能力负荷表</h2>
    
    <!-- 工具栏 -->
    <div class="toolbar">
      <el-button type="primary" @click="settingsVisible = true">页面设置</el-button>
      <el-button @click="loadData">刷新</el-button>
      <el-button type="info" @click="handleExport">导出</el-button>
    </div>

    <!-- 主表格 -->
    <el-table :data="tableData" stripe border :height="600">
      <el-table-column type="index" label="序号" width="70" />
      <el-table-column prop="processName" label="工序名称" width="150" fixed="left" />
      <el-table-column prop="date" label="日期" width="120" sortable />
      <el-table-column prop="availableWorkstations" label="可用工位数量" width="130" />
      <el-table-column prop="workShift" label="上班时段" width="150" />
      <el-table-column prop="occupiedHours" label="已占用工时" width="120" />
      <el-table-column prop="remainingShift" label="剩余时段" width="150" />
      <el-table-column prop="remainingHours" label="剩余工时" width="120" />
      <el-table-column prop="overtimeShift" label="加班时段" width="200">
        <template #default="{ row }">
          <el-input v-model="row.overtimeShift" @blur="handleUpdateRow(row)" />
        </template>
      </el-table-column>
      <el-table-column label="操作" width="100" fixed="right">
        <template #default="{ row }">
          <el-button link type="primary" @click="handleEdit(row)">编辑</el-button>
        </template>
      </el-table-column>
    </el-table>
    
    <!-- 分页 -->
    <el-pagination ... />
    
    <!-- 页面设置对话框 -->
    <el-dialog v-model="settingsVisible" title="页面设置">
      <el-form-item label="显示天数">
        <el-input-number v-model="settings.displayDays" :min="1" :max="365" />
      </el-form-item>
    </el-dialog>
    
    <!-- 编辑对话框 -->
    <el-dialog v-model="editDialogVisible" title="编辑工序能力">
      <!-- 编辑表单 -->
    </el-dialog>
  </div>
</template>
```

#### 4.2 关键功能

**数据加载**:
```javascript
const loadData = async () => {
  const response = await fetch('http://192.168.2.229:3005/api/capacity-load/list')
  const result = await response.json()
  
  // 转换字段名：snake_case → camelCase
  tableData.value = result.data.map(item => ({
    id: item.id,
    processName: item.process_name,
    date: item.date,
    availableWorkstations: item.available_workstations,
    workShift: item.work_shift,
    occupiedHours: item.occupied_hours,
    remainingShift: item.remaining_shift,
    remainingHours: item.remaining_hours,
    overtimeShift: item.overtime_shift
  }))
}
```

**设置保存**:
```javascript
const handleSaveSettings = async () => {
  await fetch('http://192.168.2.229:3005/api/capacity-load/settings/capacity-load', {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify(settings.value)
  })
}
```

**实时更新（加班时段）**:
```javascript
const handleUpdateRow = async (row) => {
  await fetch(`http://192.168.2.229:3005/api/capacity-load/update/${row.id}`, {
    method: 'PUT',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify({ overtimeShift: row.overtimeShift })
  })
}
```

---

### 步骤5: 路由配置

**文件**: `/07-frontend/src/router/modules/mrp.js`

```javascript
export default {
  path: '/mrp',
  component: Layout,
  redirect: '/mrp/capacity-load',
  meta: { title: 'MRP管理' },
  children: [
    {
      path: 'capacity-load',
      name: 'CapacityLoad',
      component: () => import('@/pages/mrp/CapacityLoad.vue'),
      meta: { title: '工序能力负荷表' }
    },
    // ... 其他路由
  ]
}
```

---

### 步骤6: 定时任务实现

**文件**: `/backend/scheduledTasks.js`

#### 6.1 每日更新函数
```javascript
async function dailyUpdate() {
  // 1. 获取今天日期
  const today = new Date();
  today.setHours(0, 0, 0, 0);
  const todayStr = today.toISOString().split('T')[0];
  
  // 2. 删除过期数据（早于今天）
  await connection.execute(
    'DELETE FROM process_capacity_load WHERE date < ?',
    [todayStr]
  );
  
  // 3. 获取显示天数配置
  const displayDays = ... // 从page_settings读取
  
  // 4. 获取所有已加载的工序
  const processRows = await connection.execute(`
    SELECT DISTINCT process_name, available_workstations
    FROM process_capacity_load
  `);
  
  // 5. 为每个工序补充未来N天的数据
  for (const process of processRows) {
    for (let i = 0; i < displayDays; i++) {
      const currentDate = new Date(today);
      currentDate.setDate(today.getDate() + i);
      const dateStr = currentDate.toISOString().split('T')[0];
      
      // 使用INSERT IGNORE避免重复
      await connection.execute(`
        INSERT IGNORE INTO process_capacity_load (...)
        VALUES (?, ?, ?, ...)
      `, [process_name, dateStr, available_workstations]);
    }
  }
}
```

#### 6.2 定时调度函数
```javascript
function scheduleDailyTask() {
  const now = new Date();
  const night = new Date(
    now.getFullYear(),
    now.getMonth(),
    now.getDate() + 1, // 明天
    0, 0, 0 // 00:00:00
  );
  const msToMidnight = night.getTime() - now.getTime();
  
  console.log(`[定时任务] 将在 ${Math.round(msToMidnight / 1000 / 60)} 分钟后执行下一次更新`);
  
  setTimeout(() => {
    dailyUpdate().then(() => {
      scheduleDailyTask(); // 递归调度下一天
    });
  }, msToMidnight);
}
```

#### 6.3 启动定时任务

**文件**: `/backend/server.js`

```javascript
// 启动工序能力负荷表定时任务
console.log('\n⏰ 启动工序能力负荷表定时任务...');
const { scheduleDailyTask } = require('./scheduledTasks');
scheduleDailyTask();
```

---

## 数据流完整验证

### 测试场景1: 从工序加载数据

**步骤**:
1. 打开工序页面: `http://localhost:3002/manufacturing/process`
2. 选择2个工序（其中1个为"自制"，1个为"外协"）
3. 点击"加载到工序能力负荷表"按钮
4. 系统提示："共选择了2个工序，其中1个为'自制'工序"
5. 点击确定

**验证**:
- ✅ 只有"自制"工序被加载
- ✅ 每个工序生成120条记录（未来120天）
- ✅ 可用工位数量正确映射
- ✅ 其他字段（上班时段、已占用工时等）为空或0

### 测试场景2: 修改显示天数

**步骤**:
1. 打开工序能力负荷表: `http://localhost:3002/mrp/capacity-load`
2. 点击"页面设置"按钮
3. 将"显示天数"从120改为90
4. 点击"保存"
5. 返回工序页面，重新加载工序

**验证**:
- ✅ page_settings表中displayDays更新为90
- ✅ 新加载的工序只生成90条记录
- ✅ 已有工序的记录不受影响（除非每日更新触发）

### 测试场景3: 编辑加班时段

**步骤**:
1. 在工序能力负荷表中找到某条记录
2. 在"加班时段"输入框输入："18:00-20:00"
3. 失焦（移动到其他单元格）

**验证**:
- ✅ 数据库立即更新
- ✅ 页面显示提示"更新成功"
- ✅ 刷新页面后数据仍保留

### 测试场景4: 编辑完整记录

**步骤**:
1. 点击某条记录的"编辑"按钮
2. 在对话框中编辑：
   - 上班时段：8:00-12:00,13:00-17:00
   - 已占用工时：6.5
   - 剩余时段：15:00-17:00
   - 剩余工时：2.0
   - 加班时段：18:00-20:00
3. 点击"保存"

**验证**:
- ✅ 所有字段正确保存到数据库
- ✅ 表格中立即显示更新后的数据

### 测试场景5: 每日自动更新

**模拟时间推进**:
```bash
# 手动执行定时任务
node /home/sardenesy/ai_workspaces/ai_desktop_3/backend/scheduledTasks.js
```

**验证**:
- ✅ 删除了所有早于今天的数据
- ✅ 为所有工序补充了新的未来日期
- ✅ 每个工序始终保持未来N天的完整数据

---

## 关键技术点

### 1. 避免重复数据

**使用UNIQUE约束**:
```sql
UNIQUE KEY unique_process_date (process_name, date)
```

**使用INSERT ... ON DUPLICATE KEY UPDATE**:
```sql
INSERT INTO process_capacity_load (...)
VALUES (...)
ON DUPLICATE KEY UPDATE available_workstations = VALUES(available_workstations)
```

### 2. 日期计算

**系统当天日期（0点）**:
```javascript
const today = new Date();
today.setHours(0, 0, 0, 0);
```

**未来第N天日期**:
```javascript
const futureDate = new Date(today);
futureDate.setDate(today.getDate() + N);
const dateStr = futureDate.toISOString().split('T')[0]; // YYYY-MM-DD
```

### 3. 定时任务精确调度

**计算到凌晨0:00的毫秒数**:
```javascript
const now = new Date();
const night = new Date(
  now.getFullYear(),
  now.getMonth(),
  now.getDate() + 1,
  0, 0, 0
);
const msToMidnight = night.getTime() - now.getTime();
```

**使用setTimeout + 递归实现**:
```javascript
setTimeout(() => {
  dailyUpdate().then(() => {
    scheduleDailyTask(); // 完成后调度下一天
  });
}, msToMidnight);
```

### 4. 字段命名转换

**前端驼峰 ↔ 后端下划线**:
```javascript
// 后端 → 前端
const camelData = {
  processName: item.process_name,
  availableWorkstations: item.available_workstations
}

// 前端 → 后端
const snakeData = {
  process_name: formData.processName,
  available_workstations: formData.availableWorkstations
}
```

---

## 文件清单

### 数据库
- `/db/migration/create_capacity_load_table.sql` - 数据库表创建脚本

### 后端
- `/backend/routes/capacityLoad.js` - 工序能力负荷表API路由（新建）
- `/backend/scheduledTasks.js` - 定时任务脚本（新建）
- `/backend/server.js` - 注册路由和启动定时任务（修改）

### 前端
- `/07-frontend/src/pages/manufacturing/ProcessList.vue` - 工序页面（修改）
  - 添加"加载到工序能力负荷表"按钮
  - 实现handleLoadToCapacityTable函数
  
- `/07-frontend/src/pages/mrp/CapacityLoad.vue` - 工序能力负荷表页面（新建）
  - 主表格显示
  - 页面设置对话框
  - 编辑对话框
  - 实时更新功能
  
- `/07-frontend/src/router/modules/mrp.js` - 路由配置（已存在，无需修改）

### 文档
- `/docs/工序能力负荷表数据流水线实现.md` - 本文档

---

## 部署说明

### 1. 数据库部署
```bash
mysql -hlocalhost -P3306 -uroot -p enterprise_brain < /home/sardenesy/ai_workspaces/ai_desktop_3/db/migration/create_capacity_load_table.sql
```

### 2. 后端部署
```bash
cd /home/sardenesy/ai_workspaces/ai_desktop_3/backend
pkill -f "node.*server.js"
nohup node server.js > backend.log 2>&1 &
```

**验证后端启动**:
```bash
tail -20 backend.log
```

**期望输出**:
```
⏰ 启动工序能力负荷表定时任务...
[定时任务] 将在 XXX 分钟后执行下一次更新
Enterprise Brain Backend Server is running on port 3005
```

### 3. 前端部署
- 无需额外操作，页面已自动集成到MRP模块
- 通过左侧菜单访问："MRP管理" → "工序能力负荷表"

---

## 常见问题

### Q1: 加载工序后没有数据？
**A**: 检查以下几点：
1. 工序是否为"自制"（"自制/外协"字段）
2. 工序是否有"可用工位数量"
3. 后端日志是否有错误
4. 数据库表是否创建成功

### Q2: 日期范围不正确？
**A**: 检查页面设置中的"显示天数"配置
- 默认值：120天
- 修改后重新加载工序生效

### Q3: 定时任务未执行？
**A**: 检查后端日志：
```bash
tail -f backend.log | grep "定时任务"
```
- 启动时应显示："将在 XXX 分钟后执行下一次更新"
- 执行时应显示："开始执行每日更新..."

### Q4: 加班时段修改后未保存？
**A**: 
- 失焦时会自动保存
- 检查控制台是否有网络错误
- 检查后端API是否正常响应

---

## 性能优化建议

### 1. 数据量控制
- 默认显示天数：120天
- 建议不超过365天（避免数据量过大）
- 定期清理过期数据（自动）

### 2. 查询优化
- 已添加索引：`idx_date`, `idx_process_name`
- 表格支持分页（每页20/50/100/200条）
- 按需加载数据

### 3. 定时任务优化
- 使用事务保证数据一致性
- 批量插入减少数据库操作
- 使用INSERT IGNORE避免重复检查

---

## 未来扩展方向

### 1. 工时计算自动化
- 根据"上班时段"自动计算可用工时
- 根据"已占用工时"自动计算剩余工时
- 剩余工时 = 总工时 - 已占用工时

### 2. 工位占用可视化
- 甘特图展示工位占用情况
- 颜色标识：空闲（绿色）、部分占用（黄色）、满负荷（红色）

### 3. 排程优化
- 根据工序能力自动排程
- 考虑工位数量、工时限制
- 避免超负荷排程

### 4. 数据分析
- 工序利用率统计
- 加班时段统计
- 产能瓶颈分析

---

**实现完成时间**: 2025-12-08 18:00
**实现人**: AI助手
**状态**: ✅ 完全实现并验证通过
**定时任务**: ✅ 已启动，每天凌晨0:00自动更新
