# 备料计划自动推送到工序计划 - 完整实现说明

## ✅ 功能概述
**核心特性**: 无论通过何种方式创建备料计划，只要备料计划编号不为空，系统都会**自动推送到工序计划**。

## 完整数据流

```
任何方式创建备料计划
    ├─ 主生产计划执行排程
    ├─ 手动新增备料计划
    ├─ 导入备料计划
    └─ API调用创建
        ↓ 自动触发（Service层）
    备料计划创建成功
        ↓ 自动推送
    工序计划自动生成
```

## 触发机制

### 触发时机（任何创建方式）
1. ✅ **主生产计划执行排程**: 点击"执行排程"按钮
2. ✅ **手动新增**: 在备料计划页面手动添加
3. ✅ **批量导入**: 通过Excel导入备料计划
4. ✅ **API调用**: 通过接口创建备料计划

### 触发条件
1. ✅ 备料计划编号不为空（`planNo`存在）
2. ✅ 备料计划创建成功

### 自动推送逻辑
- **位置**: Service层（`MaterialPreparationPlanService.create`方法）
- **时机**: 创建备料计划的同时自动推送
- **事务**: 使用数据库事务保证数据一致性

## 技术实现

### 1. 核心逻辑（Service层）

**文件**: `backend/services/materialPreparationPlanService.js`

**create方法流程**:
```javascript
static async create(data) {
  const connection = await pool.getConnection();
  try {
    await connection.beginTransaction();
    
    // 步骤1: 创建备料计划
    const [result] = await connection.execute(
      'INSERT INTO material_preparation_plans (...) VALUES (...)'
    );
    
    const insertedId = result.insertId;
    
    // 步骤2: ✅ 自动推送到工序计划（当备料计划编号不为空时）
    let processPlanNo = null;
    if (data.planNo) {
      console.log('🔄 备料计划新增，开始自动推送到工序计划...');
      
      // 2.1 生成工序计划编号
      const year = new Date().getFullYear();
      const timestamp = Date.now().toString().slice(-6);
      const random = Math.floor(Math.random() * 1000).toString().padStart(3, '0');
      processPlanNo = `PP${year}${timestamp}${random}`;
      
      // 2.2 计算计划完工日期 = 需求日期 - 1天
      let completionDate = null;
      if (data.demandDate) {
        const demandDate = new Date(data.demandDate);
        demandDate.setDate(demandDate.getDate() - 1);
        const year = demandDate.getFullYear();
        const month = String(demandDate.getMonth() + 1).padStart(2, '0');
        const day = String(demandDate.getDate()).padStart(2, '0');
        completionDate = `${year}-${month}-${day}`;
      }
      
      // 2.3 创建工序计划
      await connection.execute(`
        INSERT INTO process_plans (
          plan_no, sales_order_no, master_plan_no,
          product_code, product_name, process_name,
          product_unit, level0_demand, completion_date,
          customer_name, submitted_by, submitted_at,
          created_at, updated_at
        ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, NOW(), NOW(), NOW())
      `, [
        processPlanNo,                // 工序计划编号
        data.salesOrderNo,            // 销售订单编号
        data.sourcePlanNo,            // 主生产计划编号
        data.materialCode,            // 生产产品编号
        data.materialName,            // 生产产品名称
        data.sourceProcess,           // 工序名称
        data.materialUnit,            // 产品单位
        data.mainPlanQuantity,        // 0阶需求数量
        completionDate,               // 计划完工日期
        data.customerName,            // 客户名称
        data.submitter || 'admin'     // 提交人
      ]);
      
      console.log(`✅ 成功生成工序计划: ${processPlanNo}`);
    }
    
    // 步骤3: 提交事务
    await connection.commit();
    
    // 步骤4: 返回结果（包含工序计划编号）
    return { 
      id: insertedId,
      processPlanNo  // 生成的工序计划编号
    };
  } catch (error) {
    await connection.rollback();
    throw error;
  } finally {
    connection.release();
  }
}
```

### 2. 主生产计划执行排程接口

**文件**: `backend/routes/masterProductionPlans.js`

**改进**: 通过Service层创建备料计划，自动触发推送

```javascript
router.post('/:id/execute-schedule', async (req, res) => {
  try {
    const { id } = req.params;
    
    // 1. 查询主生产计划详情
    const [planRows] = await pool.execute(
      'SELECT * FROM master_production_plans WHERE id = ?',
      [id]
    );
    const plan = planRows[0];
    
    // 2. 生成备料计划编号
    const materialPlanNo = generateMaterialPlanNo();
    
    // 3. ✅ 通过Service层创建备料计划（会自动推送到工序计划）
    const MaterialPreparationPlanService = require('../services/materialPreparationPlanService');
    
    const materialPlanData = {
      planNo: materialPlanNo,
      sourcePlanNo: plan.plan_code,
      sourceProcess: plan.output_process,
      materialCode: plan.product_code,
      materialName: plan.product_name,
      // ... 其他字段映射
    };
    
    const result = await MaterialPreparationPlanService.create(materialPlanData);
    
    // 4. 返回结果
    res.json({
      code: 200,
      data: {
        materialPlanCount: 1,
        processPlanCount: result.processPlanNo ? 1 : 0,  // 自动生成
        processPlanNo: result.processPlanNo  // 工序计划编号
      },
      message: `排程执行成功，生成1条备料计划${result.processPlanNo ? '、1条工序计划' : ''}`
    });
  } catch (error) {
    res.status(500).json({
      code: 500,
      message: '执行排程失败: ' + error.message
    });
  }
});
```

## 数据映射规则

### 备料计划 → 工序计划

| 工序计划字段 | 映射规则 | 来源字段 |
|-------------|---------|---------|
| 工序计划编号 | 系统自动生成 | `PP{年份}{时间戳}{随机数}` |
| 销售订单编号 | = | salesOrderNo |
| 主生产计划编号 | = | sourcePlanNo |
| 生产产品编号 | = | materialCode |
| 生产产品名称 | = | materialName |
| 工序名称 | = | sourceProcess |
| 产品单位 | = | materialUnit |
| 0阶需求数量 | = | mainPlanQuantity |
| **计划完工日期** | **计算** | **demandDate - 1天** |
| 客户名称 | = | customerName |
| 提交人 | = | submitter（默认admin） |
| 提交时间 | 系统生成 | NOW() |

## 使用场景

### 场景1: 主生产计划执行排程
1. 用户在主生产计划列表选择一条计划
2. 点击"执行排程"按钮
3. 系统自动：
   - ✅ 生成1条备料计划（MPP编号）
   - ✅ 自动推送生成1条工序计划（PP编号）

### 场景2: 手动新增备料计划
1. 用户在备料计划页面点击"新增"
2. 填写备料计划信息（系统自动生成编号）
3. 保存后系统自动：
   - ✅ 创建备料计划
   - ✅ 自动推送生成1条工序计划

### 场景3: 批量导入备料计划
1. 用户通过Excel导入备料计划
2. 系统逐条创建备料计划
3. 每创建一条都自动：
   - ✅ 生成备料计划编号
   - ✅ 自动推送生成对应工序计划

## 验证方法

### 1. 执行排程验证
```bash
# 查看后端日志
tail -f /home/sardenesy/ai_workspaces/ai_desktop_3/backend/backend.log
```

**期望日志**:
```
📦 开始执行排程, 主计划ID: 123
📝 主计划信息: { planCode: 'MPS2025xxx', ... }
备料计划创建成功, ID: 456, 编号: MPP2025123456789
🔄 备料计划新增，开始自动推送到工序计划...
✅ 成功生成工序计划: PP2025987654321
   工序名称: 打包
   计划完工日期: 2025-01-15
```

### 2. 数据库验证
```sql
-- 查询最新的备料计划
SELECT * FROM material_preparation_plans ORDER BY created_at DESC LIMIT 1;

-- 查询对应的工序计划
SELECT * FROM process_plans WHERE master_plan_no = '备料计划的来源主计划编号';
```

### 3. 前端验证
- 访问备料计划页面: `http://localhost:3002/production-planning/material-preparation`
- 访问工序计划页面: `http://localhost:3002/production-planning/process-plan`
- 验证数据是否正确生成

## 涉及文件

### 后端
- ✅ `backend/services/materialPreparationPlanService.js` - **核心逻辑**（自动推送）
- ✅ `backend/routes/masterProductionPlans.js` - 执行排程接口
- `backend/routes/materialPreparationPlans.js` - 备料计划CRUD接口

### 数据库表
- `material_preparation_plans` - 备料计划表
- `process_plans` - 工序计划表
- `master_production_plans` - 主生产计划表

## 技术优势

### 1. 统一的自动化逻辑
- ✅ Service层统一处理，所有创建方式都自动推送
- ✅ 无需在每个入口重复编写推送代码
- ✅ 易于维护和扩展

### 2. 事务保证
- ✅ 使用数据库事务
- ✅ 备料计划和工序计划要么都成功，要么都失败
- ✅ 确保数据一致性

### 3. 完整的日志
- ✅ 每次推送都有详细日志
- ✅ 便于调试和追踪
- ✅ 生产环境可监控

### 4. 灵活的返回值
- ✅ 返回工序计划编号
- ✅ 前端可以展示生成结果
- ✅ 支持后续业务扩展

## 常见问题

### Q1: 如果备料计划编号为空会怎样？
**A**: 不会推送到工序计划，只创建备料计划本身。

### Q2: 如果推送失败会怎样？
**A**: 整个事务回滚，备料计划也不会创建，保证数据一致性。

### Q3: 可以手动控制是否推送吗？
**A**: 目前是自动推送，只要编号不为空就推送。如需控制，可添加配置参数。

### Q4: 多次执行排程会生成重复的工序计划吗？
**A**: 每次执行排程都会生成新的备料计划和工序计划，编号都是唯一的。

---

**功能状态**: ✅ 已实现并测试通过
**更新时间**: 2025-12-08
**实现方式**: Service层自动推送
**适用范围**: 所有创建备料计划的方式
