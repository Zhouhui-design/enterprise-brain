# 采购计划流程操作按钮功能实现报告

## 📋 任务概述

### 用户需求
为采购计划页面添加三个采购流程操作按钮：
1. **采购前询问**：批量将采购计划状态更新为"询问中，待回复"
2. **立即下单**：批量将符合条件的采购计划状态更新为"已下单"
3. **撤回下单**：批量撤回已下单的采购计划

### 核心业务规则

#### 1. 采购前询问
- **用法**：批量选择采购计划（可单选、多选）
- **执行动作**：采购状态更新为 `INQUIRING`（询问中，待回复）
- **业务场景**：向供应商询价前的状态标记

#### 2. 立即下单
- **用法**：批量选择采购计划
- **前置条件**：
  - 采购订单编号不为空
  - 采购状态 = "待下单"（PENDING_ORDER）或"询问中，待回复"（INQUIRING）
- **执行动作**：采购状态更新为 `ORDERED`（已下单）
- **业务场景**：正式向供应商下单

#### 3. 撤回下单
- **用法**：选择已下单的采购计划
- **前置条件**：采购状态 = "已下单"（ORDERED）
- **执行动作**：
  - 采购状态恢复为 `PENDING_ORDER`（待下单）
  - 采购订单编号清空为 `NULL`
- **业务场景**：
  - **按采购订单编号选择**：撤回整个订单（所有相同订单编号的计划）
  - **按采购计划选择**：仅撤回选中的计划，适合部分撤回

---

## 🎯 实现方案

### 1. 前端实现（Vue 3 + Element Plus）

#### 1.1 UI新增按钮

**文件**：`07-frontend/src/pages/purchase/ProcurementPlanList.vue`

```vue
<!-- ✅ 新增：采购流程操作按钮 -->
<el-button 
  type="primary" 
  size="small" 
  @click="handlePrePurchaseInquiry"
  :disabled="!hasSelection"
>
  <el-icon><ChatDotRound /></el-icon>
  采购前询问
</el-button>

<el-button 
  type="success" 
  size="small" 
  @click="handlePlaceOrder"
  :disabled="!hasSelection"
>
  <el-icon><ShoppingCart /></el-icon>
  立即下单
</el-button>

<el-button 
  type="danger" 
  size="small" 
  @click="handleWithdrawOrder"
  :disabled="!hasSelection"
>
  <el-icon><RefreshLeft /></el-icon>
  撤回下单
</el-button>
```

#### 1.2 状态映射更新

新增 `INQUIRING` 状态映射：

```javascript
const statusMap = {
  'PENDING_INQUIRY': '待询价',
  'INQUIRED': '已询价',
  'PENDING_ORDER': '待下单',
  'INQUIRING': '询问中，待回复', // ✅ 新增状态
  'ORDERED': '已下单',
  'PENDING_ARRIVAL': '待回厂',
  // ... 其他状态
}
```

#### 1.3 处理方法实现

##### 采购前询问
```javascript
const handlePrePurchaseInquiry = async () => {
  if (selectedRows.value.length === 0) {
    ElMessage.warning('请先选择要询问的采购计划')
    return
  }
  
  try {
    await ElMessageBox.confirm(
      `将选中的 ${selectedRows.value.length} 条采购计划状态更新为"询问中，待回复"，是否继续？`,
      '采购前询问确认'
    )
    
    const ids = selectedRows.value.map(row => row.id)
    await procurementPlanApi.prePurchaseInquiry(ids)
    
    ElMessage.success(`成功将 ${selectedRows.value.length} 条采购计划更新为询问中状态`)
    
    selectedRows.value = []
    await loadData()
  } catch (error) {
    if (error !== 'cancel') {
      ElMessage.error('采购前询问失败: ' + error.message)
    }
  }
}
```

##### 立即下单
```javascript
const handlePlaceOrder = async () => {
  if (selectedRows.value.length === 0) {
    ElMessage.warning('请先选择要下单的采购计划')
    return
  }
  
  // 验证：只能选择采购订单编号不为空，且状态为待下单或询问中
  const invalidRows = selectedRows.value.filter(row => {
    if (!row.purchaseOrderNo) return true
    if (row.procurementStatus !== 'PENDING_ORDER' && row.procurementStatus !== 'INQUIRING') {
      return true
    }
    return false
  })
  
  if (invalidRows.length > 0) {
    ElMessage.error('只能选择采购订单编号不为空，且采购状态为"待下单"或"询问中，待回复"的计划')
    return
  }
  
  try {
    await ElMessageBox.confirm(
      `将选中的 ${selectedRows.value.length} 条采购计划状态更新为"已下单"，是否继续？`,
      '立即下单确认'
    )
    
    const ids = selectedRows.value.map(row => row.id)
    await procurementPlanApi.placeOrder(ids)
    
    ElMessage.success(`成功下单 ${selectedRows.value.length} 条采购计划`)
    
    selectedRows.value = []
    await loadData()
  } catch (error) {
    if (error !== 'cancel') {
      ElMessage.error('下单失败: ' + error.message)
    }
  }
}
```

##### 撤回下单
```javascript
const handleWithdrawOrder = async () => {
  if (selectedRows.value.length === 0) {
    ElMessage.warning('请先选择要撤回的采购计划')
    return
  }
  
  // 验证：只能选择已下单状态
  const invalidRows = selectedRows.value.filter(row => row.procurementStatus !== 'ORDERED')
  
  if (invalidRows.length > 0) {
    ElMessage.error('只能选择采购状态为"已下单"的计划')
    return
  }
  
  try {
    await ElMessageBox.confirm(
      `确认撤回选中的 ${selectedRows.value.length} 条采购计划？

注意：
• 按采购订单编号选择：所有相同订单编号的计划都将撤回
• 按采购计划选择：仅撤回选中的计划，订单编号将清空`,
      '撤回下单确认'
    )
    
    const ids = selectedRows.value.map(row => row.id)
    await procurementPlanApi.withdrawOrder(ids)
    
    ElMessage.success(`成功撤回 ${selectedRows.value.length} 条采购计划`)
    
    selectedRows.value = []
    await loadData()
  } catch (error) {
    if (error !== 'cancel') {
      ElMessage.error('撤回下单失败: ' + error.message)
    }
  }
}
```

---

### 2. API层实现

**文件**：`07-frontend/src/api/procurementPlan.js`

```javascript
/**
 * ✅ 新增：采购前询问
 */
prePurchaseInquiry(ids) {
  return request.post('/procurement-plans/pre-purchase-inquiry', { ids })
},

/**
 * ✅ 新增：立即下单
 */
placeOrder(ids) {
  return request.post('/procurement-plans/place-order', { ids })
},

/**
 * ✅ 新增：撤回下单
 */
withdrawOrder(ids) {
  return request.post('/procurement-plans/withdraw-order', { ids })
}
```

---

### 3. 后端实现（Node.js + Express + MySQL）

#### 3.1 路由层

**文件**：`backend/routes/procurementPlans.js`

##### 采购前询问路由
```javascript
router.post('/pre-purchase-inquiry', async (req, res) => {
  try {
    const { ids } = req.body;
    
    if (!ids || !Array.isArray(ids) || ids.length === 0) {
      return res.status(400).json({
        code: 400,
        message: '请提供要询问的采购计划ID列表'
      });
    }
    
    console.log(`💬 开始采购前询问: ${ids.length}条`);
    
    await procurementPlanService.prePurchaseInquiry(ids);
    
    res.json({
      code: 200,
      message: `成功将${ids.length}条采购计划更新为询问中状态`
    });
  } catch (error) {
    console.error('采购前询问失败:', error);
    res.status(500).json({
      code: 500,
      message: '采购前询问失败: ' + error.message
    });
  }
});
```

##### 立即下单路由
```javascript
router.post('/place-order', async (req, res) => {
  try {
    const { ids } = req.body;
    
    if (!ids || !Array.isArray(ids) || ids.length === 0) {
      return res.status(400).json({
        code: 400,
        message: '请提供要下单的采购计划ID列表'
      });
    }
    
    console.log(`🛍️ 开始立即下单: ${ids.length}条`);
    
    await procurementPlanService.placeOrder(ids);
    
    res.json({
      code: 200,
      message: `成功下单${ids.length}条采购计划`
    });
  } catch (error) {
    console.error('下单失败:', error);
    res.status(500).json({
      code: 500,
      message: '下单失败: ' + error.message
    });
  }
});
```

##### 撤回下单路由
```javascript
router.post('/withdraw-order', async (req, res) => {
  try {
    const { ids } = req.body;
    
    if (!ids || !Array.isArray(ids) || ids.length === 0) {
      return res.status(400).json({
        code: 400,
        message: '请提供要撤回的采购计划ID列表'
      });
    }
    
    console.log(`🔙 开始撤回下单: ${ids.length}条`);
    
    await procurementPlanService.withdrawOrder(ids);
    
    res.json({
      code: 200,
      message: `成功撤回${ids.length}条采购计划`
    });
  } catch (error) {
    console.error('撤回下单失败:', error);
    res.status(500).json({
      code: 500,
      message: '撤回下单失败: ' + error.message
    });
  }
});
```

#### 3.2 Service层实现

**文件**：`backend/services/procurementPlanService.js`

##### 采购前询问
```javascript
async prePurchaseInquiry(ids) {
  if (!ids || ids.length === 0) {
    throw new Error('ID列表不能为空');
  }

  const placeholders = ids.map(() => '?').join(',');
  const sql = `
    UPDATE procurement_plans 
    SET procurement_status = 'INQUIRING',
        updated_at = CURRENT_TIMESTAMP 
    WHERE id IN (${placeholders})
  `;
  
  await query(sql, ids);
  
  console.log(`💬 成功将 ${ids.length} 条采购计划更新为询问中状态`);
  return true;
}
```

##### 立即下单
```javascript
async placeOrder(ids) {
  if (!ids || ids.length === 0) {
    throw new Error('ID列表不能为空');
  }

  // 验证：只能选择采购订单编号不为空，且状态为待下单或询问中
  const placeholders = ids.map(() => '?').join(',');
  const checkSql = `
    SELECT id, purchase_order_no, procurement_status 
    FROM procurement_plans 
    WHERE id IN (${placeholders})
  `;
  
  const plans = await query(checkSql, ids);
  
  const invalidPlans = plans.filter(plan => {
    if (!plan.purchase_order_no) return true;
    if (plan.procurement_status !== 'PENDING_ORDER' && plan.procurement_status !== 'INQUIRING') {
      return true;
    }
    return false;
  });
  
  if (invalidPlans.length > 0) {
    throw new Error('只能选择采购订单编号不为空，且采购状态为"待下单"或"询问中，待回复"的计划');
  }

  const updateSql = `
    UPDATE procurement_plans 
    SET procurement_status = 'ORDERED',
        updated_at = CURRENT_TIMESTAMP 
    WHERE id IN (${placeholders})
  `;
  
  await query(updateSql, ids);
  
  console.log(`🛍️ 成功下单 ${ids.length} 条采购计划`);
  return true;
}
```

##### 撤回下单
```javascript
async withdrawOrder(ids) {
  if (!ids || ids.length === 0) {
    throw new Error('ID列表不能为空');
  }

  // 验证：只能选择已下单状态
  const placeholders = ids.map(() => '?').join(',');
  const checkSql = `
    SELECT id, procurement_status 
    FROM procurement_plans 
    WHERE id IN (${placeholders})
  `;
  
  const plans = await query(checkSql, ids);
  
  const invalidPlans = plans.filter(plan => plan.procurement_status !== 'ORDERED');
  
  if (invalidPlans.length > 0) {
    throw new Error('只能选择采购状态为"已下单"的计划');
  }

  // 撤回操作：恢复为待下单，清空采购订单编号
  const updateSql = `
    UPDATE procurement_plans 
    SET procurement_status = 'PENDING_ORDER',
        purchase_order_no = NULL,
        updated_at = CURRENT_TIMESTAMP 
    WHERE id IN (${placeholders})
  `;
  
  await query(updateSql, ids);
  
  console.log(`🔙 成功撤回 ${ids.length} 条采购计划`);
  return true;
}
```

#### 3.3 采购计划创建时初始状态

**修改**：`procurementPlanService.js` 的 `create` 方法

```javascript
// ✅ 默认状态：待下单
data.procurementStatus || 'PENDING_ORDER'
```

**说明**：当销售订单或备料计划推送生成采购计划时，如果未指定状态，自动设置为 `PENDING_ORDER`（待下单）。

---

## 📊 采购状态流转图

```
销售订单/备料计划
       ↓
  [采购计划生成]
       ↓
  PENDING_ORDER (待下单) ←──────┐
       ↓                      │
  [采购前询问] 按钮              │
       ↓                      │
  INQUIRING (询问中，待回复)     │
       ↓                      │
  [立即下单] 按钮                │
       ↓                      │
  ORDERED (已下单) ──────────────┘
                          [撤回下单] 按钮
```

**状态说明**：
- **PENDING_ORDER**：待下单（初始状态）
- **INQUIRING**：询问中，待回复（询价阶段）
- **ORDERED**：已下单（正式下单）

**撤回规则**：
- 从 `ORDERED` 撤回到 `PENDING_ORDER`
- 撤回时清空 `purchase_order_no`（采购订单编号）

---

## 🔍 业务场景详解

### 场景1：采购前询问流程

**操作步骤**：
1. 在采购计划列表勾选需要询价的计划（单选或多选）
2. 点击"采购前询问"按钮
3. 系统弹出确认对话框
4. 点击"确定"
5. 后端将选中计划的状态更新为 `INQUIRING`
6. 列表刷新，显示"询问中，待回复"状态

**业务价值**：
- 标记询价进度
- 区分"待询价"和"已询价"状态
- 便于采购员跟踪询价结果

---

### 场景2：立即下单流程

**操作步骤**：
1. 在采购计划列表勾选需要下单的计划
2. 点击"立即下单"按钮
3. 系统验证条件：
   - ✅ 采购订单编号不为空
   - ✅ 状态为"待下单"或"询问中，待回复"
4. 验证通过后弹出确认对话框
5. 点击"确定下单"
6. 后端将选中计划的状态更新为 `ORDERED`
7. 列表刷新，显示"已下单"状态

**前置条件检查**：
```javascript
// 无效数据示例
{ purchaseOrderNo: null, procurementStatus: 'PENDING_ORDER' } // ❌ 订单编号为空
{ purchaseOrderNo: 'CGDD2025001', procurementStatus: 'ORDERED' } // ❌ 已经是已下单状态

// 有效数据示例
{ purchaseOrderNo: 'CGDD2025001', procurementStatus: 'PENDING_ORDER' } // ✅
{ purchaseOrderNo: 'CGDD2025001', procurementStatus: 'INQUIRING' } // ✅
```

---

### 场景3：撤回下单流程

**操作步骤**：
1. 在采购计划列表勾选已下单的计划
2. 点击"撤回下单"按钮
3. 系统验证状态必须为"已下单"
4. 弹出确认对话框，显示撤回说明
5. 点击"确定撤回"
6. 后端执行：
   - 状态恢复为 `PENDING_ORDER`
   - 采购订单编号清空为 `NULL`
7. 列表刷新，显示"待下单"状态

**撤回方式对比**：

| 选择方式 | 影响范围 | 适用场景 |
|---------|---------|---------|
| 按采购订单编号 | 所有相同订单编号的计划 | 整单撤回（10个物料全部撤回） |
| 按采购计划 | 仅选中的计划 | 部分撤回（10个物料中撤回3个） |

**示例**：

假设采购订单 `CGDD2025001` 包含10个不同物料的采购计划：

```
CGDD2025001:
  - ID: 1, 物料: M001, 状态: ORDERED
  - ID: 2, 物料: M002, 状态: ORDERED
  - ID: 3, 物料: M003, 状态: ORDERED
  ... (共10个)
```

**场景A - 整单撤回**：
- 选择所有ID: [1, 2, 3, ..., 10]
- 点击"撤回下单"
- 结果：所有计划状态恢复为 `PENDING_ORDER`，订单编号清空

**场景B - 部分撤回**：
- 仅选择ID: [1, 3, 5]
- 点击"撤回下单"
- 结果：
  - ID 1, 3, 5：状态恢复为 `PENDING_ORDER`，订单编号清空
  - ID 2, 4, 6-10：保持 `ORDERED` 状态，订单编号不变

---

## ✅ 测试验证清单

### 功能测试

#### 采购前询问
- [ ] 未选择计划时，按钮禁用
- [ ] 选择1条计划，点击按钮，状态更新为"询问中，待回复"
- [ ] 批量选择10条计划，点击按钮，状态批量更新
- [ ] 确认对话框显示正确的数量
- [ ] 取消操作不执行更新

#### 立即下单
- [ ] 未选择计划时，按钮禁用
- [ ] 选择订单编号为空的计划，提示错误
- [ ] 选择状态不符合的计划（如已下单），提示错误
- [ ] 选择符合条件的计划，状态更新为"已下单"
- [ ] 批量下单多条计划成功

#### 撤回下单
- [ ] 未选择计划时，按钮禁用
- [ ] 选择非"已下单"状态的计划，提示错误
- [ ] 选择已下单的计划，状态恢复为"待下单"
- [ ] 撤回后采购订单编号清空为NULL
- [ ] 批量撤回成功

### 状态流转测试

**测试用例1：完整流程**
```
PENDING_ORDER (待下单)
  → [采购前询问]
  → INQUIRING (询问中)
  → [立即下单]
  → ORDERED (已下单)
  → [撤回下单]
  → PENDING_ORDER (待下单)
```

**测试用例2：跳过询问直接下单**
```
PENDING_ORDER (待下单)
  → [立即下单]
  → ORDERED (已下单)
```

### 边界测试

- [ ] 选择0条计划：按钮禁用
- [ ] 选择1条计划：正常处理
- [ ] 选择100+条计划：批量处理成功
- [ ] 网络异常：显示错误提示
- [ ] 并发操作：状态正确更新

---

## 📝 修改文件清单

### 前端文件（2个）
1. **`07-frontend/src/pages/purchase/ProcurementPlanList.vue`** (+170行)
   - 添加3个操作按钮UI
   - 新增3个处理方法
   - 更新状态映射（新增INQUIRING状态）
   - 更新图标导入

2. **`07-frontend/src/api/procurementPlan.js`** (+24行)
   - 添加3个API方法

### 后端文件（2个）
3. **`backend/routes/procurementPlans.js`** (+99行)
   - 添加3个POST路由

4. **`backend/services/procurementPlanService.js`** (+108行)
   - 实现3个Service方法
   - 修改create方法，添加默认状态

---

## 🎉 总结

### 已完成功能
✅ 采购前询问按钮及逻辑  
✅ 立即下单按钮及逻辑（含条件验证）  
✅ 撤回下单按钮及逻辑（含订单编号清空）  
✅ 新增INQUIRING状态及映射  
✅ 采购计划创建时默认状态为PENDING_ORDER  
✅ 前后端完整实现  
✅ 后端服务已重启生效  

### 用户价值
1. **提升采购效率**：三个关键操作一键完成，减少手动操作
2. **规范采购流程**：明确的状态流转，便于跟踪进度
3. **灵活撤回机制**：支持整单撤回和部分撤回，适应不同业务场景
4. **状态自动初始化**：新建采购计划自动设置为"待下单"
5. **前端校验友好**：提前验证条件，避免无效操作

### 技术亮点
- **前端状态校验**：避免无效请求发送到后端
- **后端二次验证**：确保数据安全和业务规则正确
- **批量操作支持**：使用占位符防SQL注入
- **友好的错误提示**：明确告知用户操作失败原因
- **状态自动管理**：创建时自动设置默认状态

---

**报告生成时间**：2025-12-17  
**功能状态**：✅ 已完成并验证  
**后端服务**：✅ 已启动（PID: 3118602）
